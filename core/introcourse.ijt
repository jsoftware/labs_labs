LABTITLE=: 'An Introductory Course in J'
LABAUTHOR=: 'Henry Rich'
LABCOMMENTS=: 'Lecture notes from a 3-day class on J.'
LABERRORS=: 1
LABFOCUS=: 1

NB. ============================================================================
Lab Chapter Introduction to J
NB. ============================================================================
Lab Section Why J?
J is not primarily a computer language.  It is not a way for you to describe
things in terms that are easy for a computer to execute.

J is a language of computation.  J allows you to express your computational
ideas concisely.

You have the immense good fortune to be able to type J into a computer and
have it perform the computation for you.

When you type a J sentence, the computer evaluates it and displays the
result.
)
PREPARE
load '~addons/labs/labs/core/jpcfmt.ijs'
PREPARE
2 + 3   NB. Computer evaluates the sentence
i. 5  NB. Computer evaluates the sentence, producing a list of numbers
i. 3 5   NB.  Result of this sentence is an array of numbers

NB. ============================================================================
Lab Section J Is Weakly Typed
J has no declarations.

You may assign the result of any expression to a name and subsequently
refer to the name.  The name will hold the value assigned, which may
be a number, a character, an array, or a program.

Since names can refer to any kind of entity, and can be reassigned at will,
J is implemented with an interpreter.
)
a =: i. 2 3  NB. Assign a value to a
a  NB. look at it.
NB. To see the value assigned to a name, type the name by itself
b =: '6 + a'   NB. Create a character string
b  NB. look at it
". b  NB. Execute it!

NB. ============================================================================
Lab Section The Vocabulary of J Documentation
'Programs' and 'data' are not fundamental ideas in J, since as we have seen
what looks like data can sometimes be executed.

J uses a different terminology, one more suited to its concepts.  The terms
are borrowed from English grammar but they are given precise new meanings
in J.

VERB is the name for a program.

NOUN is the name for data, anything from a number to an array.

ADVERBs and CONJUNCTIONs [collectively called MODIFIERs] modify the
behavior of verbs and nouns in specified ways.  Modifiers are what give
J its expressive power.

All things in J, called ENTITIES, are one of the four principal parts of
speech [verb, noun, adverb, conjunction].

In this lab, we will use all-capitals to indicate the introduction of a new term, and parentheses to enclose J code n the text.
)

NB. ============================================================================
Lab Section Nouns Carry Type and Size Information
When you refer to a noun by its name, you are automatically referring to all
of it, whether it is an array or a single item.

The dimensioning of the noun [called its SHAPE] is included as part of
the noun, and you can use J's facilities to inquire about it if you need to.
)
a =: i. 2 3  NB. Create an array
a  NB. Look at it
$ a  NB.  The $ verb gives the shape of its argument
$ 'there is a tide'  NB. The character string is an array.  What is its shape?

NB. ============================================================================
Lab Section Verbs Automatically Operate On Arrays
You can ask J about the dimensioning of an array using $, but the
really great thing about J is that you seldom have to.

Every verb, including verbs you write, can be applied automatically
to an entire array.  The verb (+) means 'add'.  (a + b) is the sum of
(a) and (b), whether (a) and (b) are single numbers or arrays.

J has many different ways to generalize the way your verb is applied to an
array.  By selecting the proper forms, you can get the effect of
program loops without having to write loops by hand.
)
a =: i. 2 3   NB. Create an array
a  NB. Look at it
a + 4   NB. Add 4 to it - result is a new array
b =: a + 4  NB. Assign that new array to a name
a * b  NB. Multiply a and b, element by element.

NB. ============================================================================
Lab Section Monadic and Dyadic Verbs
Every verb in J has two forms: MONADIC, where it has one argument,
as in  - 5, and DYADIC, where it has two arguments, as in 6 - 5.

This applies to verbs you write as well as J's internal primitives.

If a verb has nouns to its left and right, it will be executed in the
dyadic form; if it has a noun only to its right, it will be executed in
the monadic form.

J is unusual in that this treatment is precisely the same for user-defined named verbs.

It makes no sense, then, to discuss 'the verb (*)' without indicating whether we are talking about the monadic or dyadic use.

Rather than say 'the verb (*) when used monadically' we will use the more compact form '(* y)'.  We will use '(x * y)' to denote the dyadic form.

In this notation we are simply generalizing normal J usage.  Within any user-defined verb the right argument goes by the name (y) and the left, if any, by (x).  Our (x * y) notation uses the same names for the arguments to primitives.

)
>. 4.5   NB. Monadic >. means 'next higher integer'
5.5 >. 4.5   NB. Dyadic >. means 'pick the larger argument'
5 + 5.5 >. 4.5

NB. ============================================================================
Lab Section No Operator Precedence; Right-to-Left Execution
Since all verbs, both J's primitives and the ones you write, are
executed with the same syntax [name with one or two arguments], it
is impossible to give a list of operator precedence, such as the
usual mathematical rules of multiplication before addition.  If you
write a verb to multiply, how is the system to give it priority over a verb
for addition?

So, J has the simplest possible rule: verbs are executed right to left.

Modifiers have a slightly more complex rule that we won't get into now.
)
NB. We can use parentheses to indicate the execution order.
1 + 2 + 3
1 + (2 + 3)
1 - 2 + 3
1 - (2 + 3)   NB. What part of 'right to left' didn't you understand?

NB. ============================================================================
Lab Section Modifiers Extend Verbs
Modifiers change the way verbs operate.

(+) is a verb.  (/) is an adverb.  So is (\).

An  adverb is written after a verb to create a modified verb.

So,
 (+/)  is a new verb
 (+\)  is a new verb
 (+/\) is a new verb

You can see that a vast number of programs can be written with just a few
keystrokes.
)
NB. The definition of (x u/ y) [where (u) is a verb] says that 
NB. it creates a table:
(0 1 2 3) +/ (0 1 2 3)   NB. Create an addition table
NB. The same modifier can be applied to a different verb to create a
NB. table for that verb
(0 1 2 3) */ (0 1 2 3)   NB. Create a multiplication table
myverb =: dyad : '2 * x >. y'"0  NB. Create a custom verb: 'double the larger'
(0 1 2 3) myverb/ (0 1 2 3)  NB. Modifier applies to user-written verbs too

NB. ============================================================================
Lab Section J's Data Types: Numbers
The primary data types in J are NUMBERs and CHARACTERs.

Numbers can be Boolean, integer, floating-point, complex, or exact.

Exact numbers are either extended-precision integers, which are as long
as necessary to hold the number exactly, or rational numbers which are
fractions whose numerator and denominator are extended-precision integers.

You generally don't have to trouble yourself about what kind of number
you have.  J will use whatever kind of number it needs to and you will
get the correct result.
)
2 ^ 50x  NB. 50x is an extended integer, so this gets an extended result
%: 16   NB. (%: y) means square root
%: -2  NB. Square root of a negative number is complex
2 % 3x  NB. (x % y) means 'divide'.  2r3 is a rational number, 2 divided by 3
2r3 - 1r2  NB. 2/3 - 1/2 = 1/6, but there's no roundoff.  The numbers are exact

NB. ============================================================================
Lab Section Numbers: The Iverson Convention
Boolean truth values, such as the results of conditionals, are
the ordinary numbers 0 [for false] and 1 [for true].  These Boolean
values can be used just like any other numbers.

Treating truth values as numbers is known to computer scientists as the
Iverson Convention, after its inventor Kenneth Iverson, who is also the
originator of J and APL.
)
NB. The verb (+/ y) adds up a list.  Think of it as Sum.
Sum =: +/  NB. Give the verb a name
Sum 1 2 3
Sum 1 2 3 4
NB. How would you find out how many items of a list are greater than 4?
Sum 4 < 3 1 4 1 5 9  NB. Just add the truth values
4 < 3 1 4 1 5 9  NB. This is the list of truth values

NB. ============================================================================
Lab Section J's Data Types: Characters
Character strings are enclosed in single quotes.

A character string containing multiple characters is automatically an array.
)
a =: 'there is a tide'  NB. A character string
a   NB. Show its value
$ a  NB. Show the shape of the array
+/ 'e' = a  NB. How many occurrences of 'e' are in the array?

NB. ============================================================================
Lab Section J's Data Types: Others
J has data types other than numbers and characters, but we will not
go into detail about them here.

The other types are SYMBOLs [which represent character
strings for high performance] and BOXes [which hold other nouns, possibly
including other boxes].
)
< 1 2 3   NB. Put a noun in a box
a =: < 1 2 3
$ a   NB. Show the shape of a
NB. Note that the shape is a blank line, denoting an empty list.  That means
NB. it has no axes, in other words it is an atom.  Its contents are a list,
NB. but the box itself is an atom.
<\ 1 2 3 4 5   NB. Create a list of boxes

NB. ============================================================================
Lab Section Surprises
There are a few basic things about J that may surprise you:

1.  Period and colon are INFLECTIONs that are suffixed to primitives or names to make
new primitives.  + +. +: and +:: are all different words.

2.  The only punctuation is control statements [if. for example] and
     ( ) ' NB. LF

  LF (end-of-line) is the only end-of-sentence sentence delimiter.

  NB. starts a comment.  Everything on a line after NB. is ignored.

3.  { } [ ] " ,  are NOT punctuation, and are NOT paired - they are
individual symbols with defined meanings.

4.  A sequence of numbers separated by spaces is taken as a single list of
numbers.  This is NOT true for names separated by spaces.
)
NB. The following is a perfectly good sentence.  The verb { means
NB. 'select', so the verb is selecting item number 2 from the list
NB. 1 2 3 4 5
2 { 1 2 3 4 5

NB. =========================================================
Lab Section Dissect, the sentence visualizer
J has a nifty tool that lets you see the execution of an entire sentence at once.  It is called Dissect.

To run it, you should have a PFkey set up to run dissect.  Look below to see what your dissect key is.  Then put your cursor on a line and press the dissect key.
A window will pop up showing the execution of your sentence.

Each block represents an input value or a result.  Arguments to a box come in at the top, and the result of the sentence is the contents of the last box.

Try dissecting this sentence:

   3 + 5

Then try writing your own sentences and dissecting them.

If you move the dissect window, subsequent executions of dissect will remember where you put it.
)
PREPARE
3 : 0 dissectfkey
if. #y do.
  smoutput 'Your dissect key is ',y
else.
  smoutput 'You do not have a dissect key, or its definition is nonstandard.  Look at the Wiki page for dissect to see how to make one'
end.
0 0 $0
)
PREPARE

NB. ============================================================================
Lab Chapter Arrays
NB. ============================================================================
Lab Section What Is An Array?
An ARRAY is a noun that contains a number of VALUES each of which is
identified by a numerical INDEX.

All the values in an array must have the same TYPE: numeric, 
character, or boxed.  There are some other exotic types that we
will not use.

An array may have any number of dimensions.

The value of an array, which is seen when you type the name, consists
of all its values.  Values are displayed starting with the element with
index 0, followed by the other elements in order.  After the last
element along a dimension has been displayed, a linefeed is typed,
the index of that dimension is set to 0, and the next-larger dimension
is advanced.

Following this rule, you can see that the number of spaces between
lines can be used to keep track of what index is wrapping around to 0.
)
i. 3 4  NB. A 3x4 array
i. 2 3 4  NB. A 3-dimensional array.  Note the extra space between 3x4 sections
i. 2 2 2 2  NB. A 4-dimensional array.  Note the spacing

NB. ============================================================================
Lab Section Terms: Axis, Shape, Rank, Atom, atom, List, Table, Empty
Each dimension of an array is called an AXIS.

The number of axes in an array is its RANK.

A noun of rank 0 is called an ATOM or a atom.  It has no axes and therefore
no indexes, and it has exactly one value.

An array of rank 1 is called a LIST.  [This has nothing to do with linked lists.]

An array of rank 2 is called a TABLE.

An array with no atoms is said to be EMPTY.

Identifying an element of the array means specifying the value of an index
for each axis.  The indexes run from 0 to [the length of the axis minus 1].
In other words, 0-origin indexing is used.

The axes are ordered such that the implied order of the elements, revealed
when they are typed or turned into a single list, comes by varying the last
axis fastest.  In other words, row-major order is used.

The list of the lengths of the axes, ordered first axis to last, is called the
SHAPE of the array.  The shape of any noun is a list.

The length of the shape is the rank.

Every empty array has a 0 somewhere in its shape.
)
NB. ($ y) shows the shape of (y):
]p =: i. 2 3  NB. A 2x3 array
$p  NB. The shape of the array
$ 0 1 2 3 4 5   NB. A list with 6 elements.  Shape is 6

NB. NOTE THE DIFFERENCE BETWEEN AN ATOM AND A LIST OF LENGTH 1:
]p =. i. 1   NB. A list with 1 element
$ p   NB. Shape is 1
1  NB. An atom
$ 1  NB. Shape is an empty list

$ 'abc'  NB. A character string
$ 'a'  NB. Note that a single character constant is an atom
$ ,'a'  NB. This is a character list of length 1

NB. ============================================================================
Lab Section Terms: Cell, Frame
A k-CELL of an array A is a subarray of A made up of all the values
of the array whose indexes differ only in the k last positions.  The rank of
a k-cell is k, and the shape of a k-cell of A is the last k elements of the
shape of A.

The part of the shape of A remaining after discarding the last k elements
of the shape is called the k-FRAME of A.  [Also called the frame of A with respect
to k-cells]

For any k, [the k-frame of A] concatenated with (the shape of a k-cell of A)
is the shape of A.

An array can be interpreted as an array of its k-cells.  The k-frame of the array
is the shape of this array of k-cells.

For k larger than the rank of A, the k-cell of A is the entire A and the k-frame
is empty.  A k of _ [infinity] is allowed.
)
NB. We will use a 2x2x3 array for demonstration:
a =: i. 2 2 3

NB. The verb (<"k y) boxes k-cells of (y), leaving an array of boxes whose shape is the
NB. k-frame.  The shape inside each box is the shape of the k-cell.
]b0 =: <"0 a  NB. Boxing 0-cells (atoms)
$ b0   NB. 0-frame of a
$ > {. , b0  NB. Shape of a 0-cell (empty)

]b1 =: <"1 a  NB. Boxing 1-cells
$ b1   NB. 1-frame of a
$ > {. , b1  NB. Shape of a 1-cell

NB. ============================================================================
Lab Section
A k-CELL of an array A is a subarray of A made up of all the values
of the array whose indexes differ only in the k last positions.  The rank of
a k-cell is k, and the shape of a k-cell of A is the last k elements of the
shape of A.

The part of the shape of A remaining after discarding the last k elements
of the shape is called the k-FRAME of A.  [Also called the frame of A with respect
to k-cells]

For any k, [the k-frame of A] concatenated with [the shape of a k-cell of A]
is the shape of A.

An array can be interpreted as an array of its k-cells.  The k-frame of the array
is the shape of this array of k-cells.

For k larger than the rank of A, the k-cell of A is the entire A and the k-frame
is empty.  A k of _ [infinity] is allowed.
)
]b2 =: <"2 a  NB. Boxing 2-cells
$ b2   NB. 2-frame of a
$ > {. , b2  NB. Shape of a 2-cell

]b3 =: <"3 a  NB. Boxing 3-cells
$ b3   NB. 3-frame of a (empty)
$ > {. , b3  NB. Shape of a 3-cell

NB. ============================================================================
Lab Section Negative Cell Rank.  Items
If k is negative, a k-cell of A is defined to be a [max[0,[rank of A+k]]-cell of A.
In other words, the k-FRAME, for negative k, comprises the [-k] leading elements
of the frame of A, and the shape of the k-cell comprises any elements of A
left over after the first [-k] are removed.

A _1-cell of A is called an ITEM of A.

An atom has 1 item, itself.  [Memorize this phrase!]
)
NB. The # verb produces the number of items in its argument:
# i. 2 3 4  NB. A 2x3x4 array has 2 items, each a 3x4 array
# 1 2 3 4  NB. A 4-item list
# 0  NB. An atom has 1 item [itself]
# ''  NB. An empty list has no items
# i. 3 0 4  NB. An empty array may have items: 3 items each a 0x4 array

NB. # $ y   gives the rank of y.  The rank is the length of the shape
# $ i. 2 3 4  NB. A rank-3 array
# $ i. 2 2 2 2 2 2  NB. A rank-6 array

NB. */ $ y  gives the number of atoms in y
*/ $ i. 2 3 4   NB. A 2x3x4 array
*/ $ i. 3 0 4  NB. An empty array
*/ $ 4   NB. An atom has one atom, itself

NB. ============================================================================
Lab Section Noun Shape = Frame Concatenated With Cell Shape
Remember, a noun's shape is an array containing the lengths of its axes.

When you view a noun as k-cells, you are splitting the noun's shape into two
parts: the last k items of the shape are the shape of the cell, and any
leftover beginning items are the frame with respect to k-cells.

So, the frame concatenated with the cell shape always recovers the shape of
the noun.

Consider a noun with shape 2 3 4 5.

 k      k-cell      k-cell         Comment
        frame       shape
 ------------------------------------------
 0      2 3 4 5     (empty)     2x3x4x5 shaped group of atoms 
 1      2 3 4       5           2x3x4 array of 5-atom lists
 2      2 3         4 5         2x3 table of 4x5 tables
 3      2           3 4 5       two 3x4x5 arrays
 4      (empty)     2 3 4 5     a single 2x3x4x5 array

 _1     2           3 4 5       two 3x4x5 arrays
 _2     2 3         4 5         2x3 table of 4x5 tables
 _3     2 3 4       5           2x3x4 array of 5-atom lists
 _4     2 3 4 5     (empty)     2x3x4x5 shaped group of atoms
)
rank4array =: i. 2 3 4 5
$rank4array
b1 =: <"1 rank4array  NB. Boxing 1-cells
$ b1   NB. 1-frame of rank4array
$ > {. , b1  NB. Shape of a 1-cell

NB. ============================================================================
Lab Section Lists of items
An array A can be thought of as an array, of length #A, of its items.
We say that A is a LIST, with length #A, OF its items.

A list of atoms is called simply a LIST.

The J term 'list' has nothing to do with linked lists.
)
<"_1   i. 3 4 5  NB. The array is a list of 3 items, each a 4x5 array

NB. ============================================================================
Lab Chapter Rank of Verbs
NB. ============================================================================
Lab Section Review of Terms
An n by m by ...   array has the SHAPE n,m,...
The shape of a noun is a list, with one number per dimension.

The shape of a noun is given by ($ noun)

The number of dimensions of the array is its RANK

The rank of a noun is given by (# $ noun)

An array with rank 0 is an ATOM, also called a SCALAR.  Its shape is an empty list.
)
] array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
$ array  NB. shape
#@$ array  NB. rank

NB. ============================================================================
Lab Section
An array can be interpreted as an array of CELLS each of which
is an array of the same rank and shape.  For example, a 2x3x4 array
can be interpreted as:
 A 2x3x4 array of cells of rank 0 [atoms]
 or A 2x3 array of cells of rank 1 [each cell has shape 4]
 or An array of 2 cells of rank 2 [each cell has shape 3x4]
 or A single entity of shape 2x3x4.

If k is greater than or equal to the rank of the array, there is a single
k-cell, containing the entire array.

Cells with rank k are called K-CELLS.

The shape of the k-cells of a noun is given by
    (k ((] {.~ [: - (<. #))  $) noun)

When the array is viewed as an array of shape (j) of k-cells, (j) is called
the FRAME of the array with respect to k-cells, or the k-FRAME of the array.

The 1-frame of a 2x3x4 array is  (2 3).

The k-frame of a noun is given by
    (k ((] }.~ [: - (<. #))  $) noun)
)
array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
cellshape =: ((] {.~ [: - (<. #))  $)
cellframe =: ((] }.~ [: - (<. #))  $)
1 cellshape array
1 cellframe array
NB. Different interpretations of the array:
('Frame';'Cell Shape') , 0 1 2 (cellframe ; cellshape)"0 _  array

NB. ============================================================================
Lab Section
The notion of k-cells can be expanded to negative values of k.  The
[-k]-CELLS of a noun have rank k less than the rank of the noun.

The _1-cells of a 2x3x4 array have rank 1 less than the array, in other
words rank 2, shape 3 4 .

The _1-cells of a noun are called the ITEMS of the noun.


An array is said to be a LIST of its items.  The 2x3x4 array is a list of
2-cells, each of which has shape 3 4.

The number of items in a noun is given by (# noun).

A list of atoms is called a LIST.

An atom has one item, which is the same as the atom itself.
)
array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
$ array
#array
$ 5  NB. An atom has no dimension, so the shape of an atom is an empty list
#@$ 5   NB. Rank of an atom is 0
# 5  NB. An atom has one item

NB. ============================================================================
Lab Section Monadic Verb Rank
Every verb has two RANKS, one for the monadic case and one for dyadic.
We will discuss monads here.

When a verb (v) with rank (r) is applied to a noun (n), the noun is
viewed as an array of (r)-cells.  Call the (r)-frame of (n) (f); then (n)
is viewed as an array, of shape (f), of (r)-cells.  (v) is applied to each
(r)-cell independently, and the result is viewed as an array of shape
(f) of cells, where each result cell comes from the application of (v) to a
single cell of (n).

The (") conjunction can be used to make a verb with a desired rank.
(v"n) is a verb with rank (n).  It applies (v) to each (n)-cell of its argument.

(v b. 0) shows the ranks of (v).  The first number is the monadic rank.
)
] array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
# b. 0  NB. Infinite rank - applies to the entire array
# array
#"2 b. 0   NB. Rank of #"2 is 2
#"2 array  NB. Applies # to each 2-cell.  There are 2 of them.
#"1 array  NB. Applies # to each 1-cell.  They make up a 2x3 array
#"0 array  NB. Applies # to each atom, a 2x3x4 array

NB. ============================================================================
Lab Section Shape of the Result
The shape of the overall result is the (r)-frame of the argument, concatenated
with the shape of the result for an individual cell.

Stop now and reread that until you thoroughly understand it.
)
](array2 =: 3 2 4 $, array) ; array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
($array2) ; ($array)  NB. array2 has shape 3 2 4, array has shape 2 3 4
NB. The verb ({. y) means 'take the first item'.
NB. ({."1 y) means 'apply ({. y) on 1-cells'
NB. Each application of {. in the following two sentences
NB. produces an atom, rank=0.  The 1-cells of array and array2 are
NB. the same, but they have different 1-frames.  The results are displayed
NB. side-by-side:
({."1 array2)  ;  ({."1 array)
NB. Shape of result is 1-frame concatenated with cell-result shape (which is empty)
($ {."1 array2) ;  ($ {."1 array)
NB. The verb (2&{. y) means 'take the array consisting of the first two items of (y)'
NB. 2&{."1 means 'apply (2&{. y) on 1-cells'
NB. Each application of (2&{. y) produces a list, rank=1, shape=2.  The 1-cells
NB. of array and array2 are the same, but they have different 1-frames
(2&{."1 array2)  ;  (2&{."1 array)
NB. Shape of result is 1-frame concatenated with cell-result shape (2)
($ 2&{."1 array2) ;  ($ 2&{."1 array)

NB. ============================================================================
Lab Section Framing Fills
The shape of the overall result is the (r)-frame of the argument, concatenated
with the shape of the result for an individual cell.

But what happens if the results for the individual cells have different
shapes?

In that case, the results are brought up to the same size by adding
padding to the shorter results.  This padding is called FRAMING FILL,
and it is 0 for numbers, ' ' for characters, or (a:) for boxes.

If the results have different rank, first they are brought up to the
same rank by adding leading axes of length 1; then fill is added.
)
] array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
NB. The spaces are framing fills:
(-.&'abe')"1 array  NB. -.&'abe' removes the letters a, b, and e
#@(-.&'abe')"1 array  NB. the length of each intermediate result

NB. ============================================================================
Lab Section Dyadic Verb Rank
Each verb has a rank when used dyadically.  This is two numbers: the
rank used on the left argument and the rank used on the right argument.

(v b. 0) shows the ranks of (v).  The first number is the rank of the monad (v y); the second number is the left rank of the dyad (x v y);
the last is the right rank of the dyad.

When the verb (v) is applied dyadically, as in (x v y), each argument has
a frame, called the LEFT FRAME and the RIGHT FRAME.

When the left frame and the right frame are identical, it means that
there is a one-to-one correspondence of cells between the left and the
right arguments.  In that case the verb (v) is applied between each
corresponding pair of cells, producing an independent result for each
pair.  These results are then treated as an array of cells whose
frame is the same as the frame of the arguments.
)
array
]selector =: 2 3 $ 0 1 2 0 1 3
{"0 1 b. 0  NB. Left rank of {"0 1 is 0, right rank is 1
0 cellframe selector  NB. Left and right frames are identical
1 cellframe array
selector {"0 1  array  NB. Each number selects a character from a list
$ selector {"0 1  array
selector {."0 1  array  NB. Each number creates a list of that length
$ selector {."0 1  array

NB. ============================================================================
Lab Section
When the left and right frame are not identical, the situation becomes
more complicated.

For an operation to be possible, the shorter frame must be a prefix
of the longer.  Failure to meet this condition produces a length error.
)
i. 2 3   NB. A 2x3 array
100 101 102 + i. 2 3   NB. length error - why?

NB. The rank of the verb (x + y) is 0 0.  The left frame is 3; the right frame is 2 3;
NB. 3 is not a prefix of 2 3; error.

100 101 + i. 2 3  NB. Left frame 2, right frame 2 3, 2 is a prefix of 2 3; OK
100 101 102 +"1 i. 2 3  NB. Left frame empty, right frame ,2; empty is a prefix of ,2; OK

NB. ============================================================================
Lab Section
The shorter frame, which is a prefix of the longer, is called the
COMMON FRAME.  The part of the longer frame that is left after the
common frame is removed is called the SURPLUS FRAME.

The argument with the shorter frame is viewed as an array of argument
cells whose shape is the common frame.  This is the same as the monadic
case we discussed previously.

The argument with the longer frame is viewed as an array of subarrays, where
each subarray is an array of argument cells whose shape is the surplus frame.
The argument is an array of these subarrays, with shape equal to the common
frame.

Each cell of the shorter-frame argument is matched with the corresponding
subarray of the longer-frame argument.  The verb is applied between
the shorter-frame cell and each cell in the longer-frame subarray.
The results of the individual applications of the verb are collected into an
array using the longer frame.

You may think of each individual cell of the shorter-frame argument as
being duplicated to make up for the surplus frame of the corresponding
part of the longer-frame argument.

Use dissect to display the examples below.
)
100 101 + i. 2 3  NB. left frame 2, right frame 2 3, common frame 2, surplus 3
array
NB. left frame empty, right frame 2 3, common empty, surplus 2 3
NB. cell result shape empty, overall result shape 2 3
2 {"1 array
NB. left frame empty, right frame 2, common empty, surplus 2
NB. cell result shape 4, overall result shape 2 4
2 {"2 array
NB. left frame 2, right frame 2 3, common 2, surplus 3
NB. cell result shape empty, overall result shape 2 3
0 2 {"0 1 array
NB. left frame 2, right frame 2, common 2, surplus empty
NB. cell result shape 4, overall result shape 2 4
0 2 {"0 2 array

NB. ============================================================================
Lab Section
Of course, just having the frames of the arguments match does not guarantee
that the operation can be performed.

The resulting cells must also be valid for the verb they are passed into.
)
NB. The following line fails because there are two layers of verb: (+"1) is
NB. the outer layer.  It matches up the left-side 1-cell [100 101] with each
NB. right-side cell, and passes those pairs to the inner verb which is (+).
NB. But (+) cannot add lists of different lengths, and it fails.
NB.
NB. The error does come from a mismatch of frames, but it is a mismatch
NB. in the arguments to (+), not the arguments to (+"1).
100 101 +"1 i. 2 3
NB. With a verb that can handle differently-shaped arguments, like (,)
NB. instead of (+), the operation succeeds.
100 101 ,"1 i. 2 3
NB. The inner verb can fail for other reasons too, not just agreement:
NB. (here the problem is that 100 101 {. y expects a table for y)
100 101 {."1 i. 2 3

NB. ============================================================================
Lab Section Nested Rank Specification
The rank operator produces implicit looping.  You can nest rank
operators to produce nested loops.

In the verb (u"r"s), the verb is executed as ((u"r)"s); in other
words, the argument cells are matched up using the shape s;
then, within each corresponding pair of cells, subcells are
matched up according to the shape r.

Dissect the following example lines to see a picture of the computation.
)
NB. Execution of  100 200 +"0"0 1 (1 2 3 4) :
NB. First, the rank 0 1 is used.  The left argument has the longer
NB.   frame, with surplus frame 2; cells of the right argument are replicated
NB.   accordingly.  There is only one right-argument cell, 1 2 3 4
NB. Then, (+"0) is executed between each cell of the left argument
NB.   (which has rank 0) and each cell of the right argument (which has
NB.   rank 1); this causes the left-argument cells to be replicated.
100 200 +"0"0 1 (1 2 3 4)
NB. The intermediate step can be seen by displaying the arguments to +"0 :
100 200 (<@;)"0 1 (1 2 3 4)
NB. The arguments as they are matched before the final addition:
100 200 (<@;)"0"0 1 (1 2 3 4)

NB. ============================================================================
Lab Chapter Scripts and Explicit Definitions
NB. ============================================================================
Lab Section Scripts
So far we have written single sentences.  You can do a lot with a J sentence, but the time will come when you want to write a verb containing several sentences.

You will write your verb in a SCRIPT, a file with extension .ijs.  You can use your favorite editor to edit your script, or you can use J's built-in edit window.  To run a verb in the script, you first LOAD the script, which feeds the lines of the script into the interpreter as if you had typed them from the keyboard.  

We have created a sample script in the edit window.

We have also created a debug window that you can use to stop and single-step through your verbs.  The debug window is the short window toward the top-right of the screen.
)
PREPARE
require 'format/printf'
'covar' opendebscript 0 : 0
NB. Calculate covariance of two lists
NB. x and y are the lists
NB. If x is omitted, y is used, giving variance of y
NB. Calculates mean of each first, then finds average of the product of deviations
NB. Result is covariance (atom)
covar =: verb define
NB.~stop 0
qprintf 'y '
NB.~stop covarm
NB.~title 3	Covariance of Two Lists
NB.~title1 0	Monad: default x=y
NB.~link0 0	Assignment	http://www.jsoftware.com/jwiki/Vocabulary/Assignment
NB.~link1 0	Verb Definition	http://www.jsoftware.com/jwiki/Vocabulary/coa
NB.~link2 0	Control Words	http://www.jsoftware.com/help/dictionary/ctrl.htm
NB. monad: take covariance of y with itself
y covar y
:
NB.~stop covard
NB.~title 3	Covariance of Two Lists
NB.~title1 0	Test for empty list
NB.~link0 0	Assignment	http://www.jsoftware.com/jwiki/Vocabulary/Assignment
NB.~link1 0	Verb Definition	http://www.jsoftware.com/jwiki/Vocabulary/coa
NB.~link2 0	Control Words	http://www.jsoftware.com/help/dictionary/ctrl.htm
if. 0 = #y do.
  smoutput 'empty covariance'
  0 return.
end.
NB.~title1 0	Total of x
sumx =. +/ x
NB.~title1 0	Mean of x
meanx =. sumx % (#x)
NB.~title1 0	Mean of y
meany =. (+/ y) % #y
NB. Save meany in a global for external visibility
NB.~title1 0	Save mean of y in a public name
DMEANY   =: meany   NB. debug
NB.~auto 0
NB.~stop
qprintf 'meanx meany '   NB. debug
NB.~auto 1
NB.~stop covard
NB.~title1 0	Final result
(+/ (x-meanx)*(y-meany)) % #x
))
)

NB. Turn off debug to begin with
0 debugchangestops ;:'covarm covard'
PREPARE

NB. ============================================================================
Lab Section load and lint
To load the script, you have two options.

If you feel lucky, you can just load the script by pressing Ctrl+L.

If you want to run a static analysis of the verbs in your script, to find things like uninitialized names and omitted verb endings, run lint.  If you have the explorer profile, function key F4 runs lint on the current edit window.

lint is described in its page http://www.jsoftware.com/jwiki/Vocabulary/Lint

NB. ============================================================================
Lab Section Running the Verb; Passing Arguments
This script defines a verb named covar that calculates the covariance of two lists.

You run this verb the same way you run any verb: by giving it a right argument [for monadic execution] or right and left arguments [for dyadic execution].

The way the argument[s] are passed into the verb is very simple: before the verb starts running, the name (y) is set to the value of the right argument, and if there is a left argument, its value is assigned to the name (x).

This simple method works because all J verbs have either 1 or 2 arguments.

After the arguments are set, the sentences of the verb are executed one by one until there aren't any more, and the result of the last one becomes the result of the verb.
)
1 2 3 4 5 covar 5 4 3 2 1

NB. ============================================================================
Lab Section How Was The Verb Defined?
The definition of the verb covar started with the line

covar =: verb define

and ended with the line containing a single ) character.
The lines in between are the body of the verb.

A verb defined using (verb define) or its variants (monad define), (dyad define), (3 : 0), or (4 : 0) is called an explicitly defined verb.  Modifiers can also be created using (define); they are called explicit modifiers.

A script can contain any number of such verb-definitions, along with any other sentences you want to execute.  Loading the script executes the lines of the script; those lines that contain verb-definitions create those verbs, which you can then use.

If you want to change the definition of a verb, you simply execute a new verb-definition for that name.  The usual way is to edit the script containing the verb-definition, and then reload the script.  You can do this at any time.

To get an understanding of what is happening inside the verb, we use the debugger.  The debugger allows us to stop and single-step verbs, and dissect the sentences as they are executed.

Normally you bring up the debugger by pressing Ctrl+k, and then install stops using the Stops Manager.  There is a lab that explains how to use Debug.

To save you the trouble, this lab has automatically started Debug and set a stop on each line of the verb covar.

When you advance this lab, the debugger will spring to life, stopping before the execution of the first line of covar.
)
PREPARE
1 debugchangestops ;:'covarm covard'
PREPARE

NB. ============================================================================
Lab Section Check For Empty Input
The debugger has awakened, and has dissected the first line.

Click on the link titled 'Verb Definition' at the top-left of the dissect window.  This will point your browser to the reference page that explains verb definition using this example verb.  As you step through the execution, follow along with the discussion there.

The first line checks to see whether the input is empty.
)
1 2 3 4 5 covar 5 4 3 2 1

NB. ============================================================================
Lab Section Total x values
The reference page discussing this verb gives an annotated line-by-line explanation of what is going on.  Refer to that analysis as you step through the verb.

Here we add the x values.

)
debugrun''

NB. ============================================================================
Lab Section Calculate mean of x
We calculate the mean of x.
)
debugrun''

NB. ============================================================================
Lab Section Calculate mean of y
We calculate the mean of y.
)
debugrun''

NB. ============================================================================
Lab Section Save the mean of y in a global
The assignments in the verb, to sumx, meanx, and meany, have all been private assignments that will be invisible outside the execution of the verb covar.  If we want to be able to see one of these values after covar has executed, we need to save it in a public name.  Here we assign the name DMEANY.
)
debugrun''

NB. ============================================================================
Lab Section Calculate result
We calculate the covariance.
)
debugrun''

NB. ============================================================================
Lab Section Run to completion
The calculated result is returned and J displays it.
)
0 debugchangestops ;:'covarm covard'
debugrunstop''

NB. ============================================================================
Lab Section Multiple Assignment
Only two arguments are allowed to a verb, but everybody knows that functions may need lots of arguments.  How does J handle that?

With a simple two-step.  The arguments are combined into a single package that is passed into the verb; then the package is opened inside the verb.

The example below shows how.  The execution of the verb is

polyint poly;low;high

The (poly;low;high) part creates a single noun containing the three values (in the next chapter you'll learn more about this).  Then the first line of the verb is

'poly a b' =. y

which splits the noun into its three parts, giving each the name the verb knows them by.
)
NB. y is (polynomial);(lower limit);(upper limit)
NB. Result is integral of polynomial between the limits
polyint =: monad define
'poly a b' =. y
'aderiva aderivb' =. (0 p.. poly) p. a,b
aderivb-aderiva
)

poly =. 1 2 2  NB. 2x^2 + 2x +1
low =. 1
high =. 3

polyint poly;low;high

NB. ============================================================================
Lab Section Public and Private Names
When an explicit definition [call it (V)] starts execution, it receives a private namespace.  Names defined in this namespace are not accessible to other verbs: not to verbs called by the verb (V), nor verbs that called (V).

To assign a name in this private namespace, use (=.) for the assignment.  To assign the name in a public namespace accessible to all verbs, use (=:).

In the example of the previous section, all the names assigned inside (polyint) were private.  This is good practice.  None of those names could affect or be affected by names used outside polyint.  The name poly was used both outside and inside the verb; those two names are disticnt and do not interact.

If no explicit definition is running, (=.) acts like (=:) and assigns to the public namespace.  The assignment

poly =. 1 2 2

was made in the public namespace for this reason.

When an explicit definition starts execution, the names (y) and [for dyads] (x) are assigned in the private namespace.

NB. ============================================================================
Lab Section Valence
Every verb can be executed as a monad or dyad.  Which valence is used depends on the invocation of the verb, not the definition.  As the writer of the verb you have no control over which valence a user will try.

If the user attempts to use a valence that you have not defined, the result will be "domain error".  Thus, if you define a verb with (monad define) and the user executes it as a dyad, or if you define the verb with (dyad define) and the user executes it as a monad, domain error will be signalled.

But suppose you want to let your verb have both a monadic and dyadic meaning?

Then you define your verb like this:

 name =: verb define
 ...sentences of monadic valence...
 :
 ...sentence of dyadic valence
 )

The verb covar [defined a few sections back illustrates this.
)

NB. ============================================================================
Lab Section Control Words
Words that consist of a name followed by a period are reserved for Control Words.  The list of allowed control words, and a full discussion of them, is given at

http://www.jsoftware.com/help/dictionary/ctrl.htm

Control words provide the usual testing and looping facilities.  Here we mention only some subtleties.

1.  Control words are allowed only inside an explicit definition.  Outside, they are considered "spelling errors".  See the example below for a way to create a temporary explicit definition to allow you to use (if.).

2.  (for. array do.)
 starts a loop with a fixed number of iterations.  The number of iterations is the number of items of (array).  So, to execute 10 iterations, use

for. i. 10 do.

3.  (for_name. array do.)
 also runs a fixed number of iterations, one for each item of (array), but it defines the (name) at the start of each iteration to hold the value of the corresponding item.

4.  If you use (elseif.) in a construct, you may not use (else.) in that construct.

Bad:
  if. x > 0 do.
    ...
  elseif. x = 0 do.
    ...
  else.
    ...
  end.

Good:
  if. x > 0 do.
    ...
  elseif. x = 0 do.
    ...
  elseif. do.
    ...
  end.

Observe that the empty test (elseif. do.) tests true.
)
if. IFQT do.  NB. Oops, not allowed outside of explicit

3 : 0 ''   NB. Create an anonymous verb and immediately run it
if. IFQT do.
  value =: 0
else.
  value =: 1
end.
)

NB. ============================================================================
Lab Chapter Boxed Data
NB. ============================================================================
Lab Section The Boxed Data Type
The BOX is one of J's basic data types, along with character and numeric.
A single box is an atom [aka scalar].  An array can have the boxed
data type, in which case each atom in the array is a box.

A box has CONTENTS, which can be any noun.  The contents of a box
can be an array, even an array of boxes; you can create a nesting
doll of boxes within boxes, as many layers as you want.

When you display a boxed noun, the box is drawn around the contents using
line-drawing characters.

A noun is said to be BOXED or UNBOXED.  OPEN is used as a synonym for
UNBOXED.  The term 'boxed list' is ambiguous: does it mean a list
that has been put into a box, or a list of boxes?  We will say here
that a 'boxed list' is a list that has been put into a box, and a
'list of boxes' is a list each of whose items is a box.  This terminology
is not standardized in J documentation.
)

NB. ============================================================================
Lab Section Creating Boxes: (< y) [Box] and (> y) [Open]
(< y) creates a single [atomic] box whose contents are (y).

Monad < has infinite rank, since you can put anything into a box.
)
<'abc'   NB. A single box
< i. 2 3  NB. A box containing an array
<"0 i. 2 3  NB. Box each atom, giving a 2x3 array of boxes
<"1 i. 2 3  NB. Box each list, giving a 2-item list of boxes
(< 0 1) , (< 2 3 4 5)  NB. Contents of boxes are independent
(<0 1) , (<'abc')
< (<0 1) , (<'abc')  NB. A boxed list can be boxed again

NB. ============================================================================
Lab Section
(> y) opens a box, giving the contents of y.

(> y) has rank 0, since boxes are independent and you want to open each
one individually.
)
>  <'abc'   NB. Opening a box returns its contents
>  <"1 i. 2 3
NB. The boxes were opened independently, giving 2 lists, which were
NB. then assembled into an array.
> (< 0 1) , (< 2 3 4 5)  NB. Note that the assembly into an array may add fills
> (<0 1) , (<'abc')  NB. In fact, it may not even be possible
NB. A single array containing characters and numbers is not allowed, so the
NB. attempt to create one failed

> 1 { (<0 1) , (<'abc')   NB. 1 {   selects just box 1 which can be opened

NB. ============================================================================
Lab Section Creating Boxes: (x ; y) [Link]
(x ; y) creates a list of boxes out of (x) and (y).  (x) is always put into a box; (y) is
put into a box only if it is not boxed already; then the boxes are concatenated
into a list.

This asymmetrical definition causes an expression like

  x ; y ; z

to box each argument exactly once if they were all unboxed initially.
This is usually what you want.  If (z) is boxed, and you want to add
a boxing level to it too, you must write

  x ; y ;< z

to force boxing of the last item in the chain.  If you leave out the (<) for boxed (z), the result may be an array of any rank rather than a list, and will probably not be what you want.

If you just want to add one level of boxing regardless of the initial
condition, use

  x ,&< y
)
1 ; 2 3 ; 4 5   NB. Create a list of boxes
1 ,&< 2 3 ,&< 4 5   NB. ,&< is not usually what you want
(1 ; 2) ; (3 4 ; 4 5)  NB. Do you expect 2 boxes or 3?
(1 ; 2) ,&< (3 4 ; 4 5)  NB. One way to get 2 boxes
(1 ; 2) ;< (3 4 ; 4 5)  NB. Another way

]y =: 1 2 $ (1 2;3 4)  NB. An array of two boxes
9 10 ; y  NB. Oops, forgot to box y
9 10 ;< y  NB. This is what I meant

NB. ============================================================================
Lab Section Words  (;: y)
(;: y) operates on a character (y) to produce a boxed list with the words of
(y) in separate boxes.

The definition of 'word' is the one J uses for parsing sentences.  This
has all of the quirks of J syntax, but you may find it useful.

If you want to split a list into words separated by a delimiter
character, use

  <;._1 delimiter,string

Other partition functions can also be used to parse strings.
)
;: 'this is a sentence'
;: 'testing 1 2 3  numeric list is 1 word;  NB. a comment is a single word'
;: 'Period is an inflection.  When not preceded by space .'
;: 'mismatched quotes aren''t allowed'

<;._1  ' ','mismatched quotes aren''t allowed'

NB. ============================================================================
Lab Section Test Boxing Level (L. y)
(L. y) tells you the boxing level of (y).
)
L. i. 2 3  NB. 0 means unboxed
L. < i. 2 3  NB. boxed once...
L. < < i. 2 3  NB. ...twice...
L. < < < i. 2 3  NB. ...three times

>^:L.   < < < i. 2 3  NB. calculate boxing level, and open that many times

NB. ============================================================================
Lab Section Apply At Level  (u L:n) (u S:n)
(u L: n) is a verb that applies (u) within the boxed structure of
its argument(s), at boxing level (n).

The most common use is (u L: 0) which applies (u) within the innermost boxes.

The details of (u L: n) when (n) is not 0, or when the compound is used
dyadically, are rather intricate and you should refer to NuVoc if you need the details.


(u S: n) applies (u) at the same places as (u L: n), but instead of leaving
the result in the boxed structure, the results of applying (u) are assembled
into an array.
)
] a =: ( ('abc' ; 'de') ; 'fghi') ; 'jkl' ; 'mno'  NB. Boxes
$ L:0 a  NB. Get the shape of each innermost box
$ L:1 a  NB. Go through the boxes stopping when you hit a boxing level of 1

$ S:0 a  NB. Assemble shapes into a list

NB. ============================================================================
Lab Section Comparisons on Boxes
A limited set of comparison operation work on boxes.  Boxes can be compared for
equality, but not for greater-than or less-than.

Boxes are equal if the contents of the boxes MATCH.  Two nouns match
if they have the same shape and item values.  Empty arguments of the
same shape are considered to match even if they have different types.

When the contents of boxes are compared for equality of values, tolerant
comparison is used.

The verbs for ordering are (x /: y) [grade up], (x \: y) [grade down], and (I. y) [insertion index].  They
contain implied comparisons that test for greater-than and less-than as well
as equality.  These implied comparisons DO work for boxed values, so you can
sort boxes into order based on their contents.
)
(<3) = (<3)  NB. Two equal boxes
(<3) = 2 ; 3 ; 4  NB. = has rank 0, so there are 3 comparisons
(<1) =    <1.00000000000001  NB. Tolerant comparison
(<1) =!.0 <1.00000000000001  NB. Intolerant comparison
'a' = <3  NB. No domain error, but a character is never equal to a box
(<'a') = <3  NB. Nor do the contents match
(<$0) = <''  NB. The empties have different type, but they match
(<3) < (<4)   NB. Greater-than comparison not allowed
/:~ ;: 'there is a tide in the affairs of men'  NB. OK to sort boxed strings

NB. ============================================================================
Lab Section Fetch (x {:: y)
(x {:: y)  selects item (x) from (y) and opens it.

Actually it does a good deal more than that, but we will not
get the full story until we have discussed selection in detail.
)
]a =: ;: 'there is a tide in the affairs of men'
1 {:: a  NB. Open box 1
3 {:: a  NB. Open box 3
NB. More to come...

NB. ============================================================================
Lab Section Similarity to C Structures
A C structure is a single entity that contains a sequence of other
entities.

That is like a list of boxes in J.

An array of C structures is like a higher-rank array of boxes.

A structure of arrays is like a list of boxes where the contents of a box
are an array.

C has nothing analogous to a single box.

(x {:: y) is analogous to accessing a structure element in C.
)

NB. ============================================================================
Lab Chapter Selected Verbs For Arrays
NB. ============================================================================
Lab Section (i. y) and (i: y)
(i. y) creates a numeric noun whose shape is (y), and whose atoms are
consecutive integers.  We will use (i. y) often to create nouns for
demonstrating the topics under discussion.  (i. y) has rank 1, because
the shape can be a list of any length.

(i: y) creates a noun containing integers running from (-y) to (y).  It has rank 0.
)
i. 4   NB. A list of 4 integers
i. 3 4   NB. A 3x4 array of integers
i. 2 3 4  NB. A 2x3x4 array of integers
i. 0  NB. An empty array of integers
$ i. 0   NB. It's a list with shape ,0

i: 3
i: _3

NB. ============================================================================
Lab Section (x # y) [Select Items Using a Mask]
(x # y) uses (x) as a mask to select items of (y).  The rank is (1 _) so that
(x) is a numeric list, and (y) can have any rank.  (x) may be an atom, in which case it applies to each item of (y); otherwise  (#x) must be the same as (#y).
Each item of (x) gives the number of copies to keep of the corresponding
item of (y).

The result is a list whose items are items of (y); therefore it has the
same rank as (y) [unless (y) is atom], and its items have the same shape
as items of (y), but the number of items of the result is usually different from
the number of items of (y).

In the most common case, where x is a Boolean list, the result contains just
those items of (y) for which the item of (x) is 1.

If (x) contains values greater than 1, the corresponding items of (y) are repeated
in the result.

If an item of (x) is complex, the imaginary part tells how many FILLs to insert
after the items of (y).  Fills are cells with the shape of items of (y), but
whose atoms are 0 [for numeric (y)], ' ' [for character (y)], or (a:) [for boxed (y)].
The fill can be changed using the Fit conjunction (!.), as discussed later.
)
1 0 1 # 'abc'  NB. Keep items corresponding to 1, discard corresponding to 0
1 0 2 # 'abc'  NB. Repeat an item
1 0 1 # i. 3 4  NB. ITEMs are selected
0 # i. 3 4  NB.  Atomic x; it's like 0 0 0.  What is the shape of the result?
$ 0 # i. 3 4  NB. It's a list of 0 items of length 4
1j1 0 1 # 'abc'  NB. Insert a fill after item 0
NB. Alas, there's no way to insert a fill before the first item
1j1 0 1 #!.'*' 'abc'   NB. Insert a fill, but use * for the fill

NB. ============================================================================
Lab Section (x { y) (Select Items By Index)
(x { y) selects parts of (y) specified by (x).  The general form of (x { y), where (x) is
boxed, gives detailed control over the portions of (y) that are to be selected.
We will cover that later.  Here we will cover the case of unboxed numeric (x).

When (x) is a nonnegative numeric atom, (x { y) selects item number (x) from (y).
The first item is selected by 0 and the last is selected by ((#y)-1).
(x) may not be larger than ((#y)-1).

When (x) is negative, (x { y) selects item number (x+(#y)).  For example, _1 selects
item ((#y)-1), in other words, the last item.  _2 selects the next-to-last item, and so on.  The last item is selected by _1
and the first one by (-#y).  (x) may not be less than (-#y).

The rank of (x { y) is (0 _) which means that if (x) is an array, the result of
(x { y) is an array of items of (y).
)
2 { 'abcdefgh'   NB. Select item 2
2 { i. 3 4   NB. Here item 2 is a list
3 { i. 3 4   NB. If you index past the end, you get an error
2 1 3 { 'abcdefgh'  NB. Select 3 items, run them into a list.
(2 2 $ 3 0 1 5) { 'abcdefgh'  NB. Shape and order of indexes is preserved

NB. ============================================================================
Lab Section (|. y), (|: y), and (x |: y) [Reverse and Transpose]
(|. y) reverses the order of the items of (y).  Pay attention to that word 'items'!
Only the first axis is reversed.

(|: y) reverses the AXES of (y).  For a rank-2 array, this is the matrix-transpose
operation: an mxn table becomes an nxm table.

(x |: y) is a generalization of the transpose.  (x) is a list of axis numbers, and
the axes are reordered, moving the given axes to the end.
)
|. 'abcde'  NB. Reverse order of items, atoms here
|. i. 3 4  NB. Reverse order of items, lists here.  Each list is unchanged

|: i. 2 4  NB. Transpose a 2x4 matrix, giving a 4x2 matrix
|: i. 2 3 4   NB. Transpose of a rank-3 array.  Shape is 4 3 2

0 |: i. 2 3 4  NB. Axis 0 moves to end of axes, so shape is 3 4 2

NB. ============================================================================
Lab Section (x |. y) [Left Rotate and Left Shift]
(x |. y) has nothing to do with reversing or transposing axes.  It is the
Left Rotate operation, where (x) tells how many places to rotate (y) left.  The operation is performed along the leading axis of (y), with each item of (y) moving as a unit.

If (x) is negative, that is a Right Rotate by -x places.

In a Rotate, the values that are pushed off the end of the array are moved
into the vacated positions on the other end.  This differs from a Shift,
in which the values pushed off the end are discarded, and the vacated
positions are filled with a constant.

To perform a Left Shift, you specify the constant to use for the fill, with
the Fit conjunction:  (x |.!.0 y) is a Left Shift, filling with 0.

The rank of (x |. y) is (1 _) which means that when (x) is a list it is not simply treated as a set of simple rotations on items; instead, the atoms of (x) give the rotate/shift amounts for successive axes.
Axes beyond (#x), that is, axes whose rotate/shift count is omitted,
are left unchanged.  In the most common case, where (x) is an atom, this
means that the first axis is rotated/shifted, but no rotation is performed within items.
)
2 |. 'abcdefgh'  NB. Rotate left 2
_2 |. 'abcdefgh'  NB. Rotate right 2
2 |.!.'*' 'abcdefgh'  NB. Shift left 2, fill with *
_2 |.!.'*' 'abcdefgh'  NB. Shift right 2, fill with *

1 |.!.99 i. 3 4  NB. Shift left, first axis only.  Items are unaltered

1 _2 |.!.99 i. 3 4  NB. Shift Axis 0 left 1, axis 1 right 2

NB. ============================================================================
Lab Section ({.), ({:), (}.), and (}:) [Take and Drop]
The suite of verbs ({. {: }. }:) perform the Take and Drop functions.
Take is selecting sequential items from the beginning or end of an
array; Drop is discarding sequential items from the beginning or end of
an array.

(x {. y) is Take.  (x) tells how many items of (y) to keep.  The result has
(|x) items, and will have the same rank as (y) [unless y is atom].
If (x) is positive, (x) items are taken beginning at the first item;
if (x) is negative, (-x) items of (y) are taken ending at the last item.

The rank of ({. y) is 1 _ which means that (x) can be a list, in which case
successive atoms of (x) specify the amount to be taken from successive axes
of (y).  A value of (_) [infinity] means 'take the entire axis'.  Axes beyond (#x) are left unchanged.

The shape of the result always has (x) as its starting prefix.  If an atom of (x)
specifies more items than exist for that axis, that is called an OVERTAKE and
the surplus items are created as fill cells: (0), (' '), or (a:) depending on the
type of (y).  The value of the fill cell can be overridden with the Fit conjunction (!.).
)
3 {. 'abcdefgh'   NB. Take the first 3 items
_3 {. 'abcdefgh'  NB. Take the last 3 items
4 {. 5 6  NB. Overtake: extra position is fill
_4 {. 5 6  NB. Overtake: extra position (at front) is fill
4 {.!.99 (5 6)  NB. Overtake, with fill specified

_2 {. i. 4 5  NB. Take the last 2 items of a 4x5 array.  Items are unchanged
_2 2 {. i. 4 5  NB. Take last 2 items, first 2 atoms of each item

_ 2 {. i. 4 5   NB. Infinite value for an axis means 'take it all'

NB. ============================================================================
Lab Section
(x }. y) is Drop.  It is like Take, but (x) gives the number of items
to be discarded from the front [if (x) is positive] or the end
[if (x) is negative] of the array.  If Drop is instructed to discard
more items than exist, it will be content with discarding all that exist.

As with Take, the result is a list of items of (y), and therefore the rank of
the result is the same as the rank of (y) [unless (y) is an atom].

As with Take, (x) may be a list specifying the amounts to drop for successive
axes.



The handy monads ({. {: }. }:) are defined in terms of ({.) and (}.).

 (}. y) is equivalent to (1 }. y),  i. e. discard the first item
 (}: y) is equivalent to (_1 }. y),  i. e. discard the last item

 ({. y) is equivalent to (0 { 1 {. y),  i. e. just the first item
 ({: y) is equivalent to (0 { _1 {. y),  i. e. just the last item

Note that ({. y) and ({: y) produce a result that has rank 1 less than that
of (y) [unless (y) is an atom].  They return just a single item, not a
list with that item as the only element.
)
3 }. 'abcdefgh'   NB. Drop the first 3 items
_3 }. 'abcdefgh'  NB. Drop the last 3 items

{. i. 3 4  NB. Take the first item
$ {. i. 3 4  NB. Note: result has rank 1

}. i. 3 4  NB. Drop the first item

NB. ============================================================================
Lab Section (/:) and (\:) [Grade/Sort, ascending and descending]
J has a novel way of defining sorting.  Once you get used to it, you will
find it to be very powerful.

(/: y) produces the ASCENDING GRADING PERMUTATION for (y).  This permutation is
defined by saying that ((/: y) { y) has items in ascending order.  A permutation is always a numeric list.

What that means is that item (i) of (/: y) contains the index of the item in
y that should end up in position (i) when the items of (y)are sorted into order.

So, atom 0 (the head) of (/: y) is the index of the smallest item of (y).
Atom 1 is the index of the next-smallest, and so on, with the last atom of
(/: y) being the index of the largest item of (y).

Another way to say the same thing is: find the smallest item of (y); its
index becomes the first atom of (/: y).  Then find the next-smallest; its
index becomes atom 1 of (/: y); and so on.

If (y) contains repeated items, the sorted order is the one that is stable,
in other words the one that keeps equal items in order.
)
/: 'abcde'   NB. The grading permutation keeps the list as is
/: 'edcba'   NB. The grading permutation reverses the order...
(/: 'edcba') { 'edcba'   NB. ...as you can see.
/: 3 1 4 1 5 9   NB. Item 1 is smallest; then item 3, then 0, etc.
(/: 3 1 4 1 5 9) { 3 1 4 1 5 9  NB. This puts the list in order
]b =: ;: 'bright is the ring of words'  NB. A list of boxes
/: b   NB. Every list can be sorted into a unique order

NB. ============================================================================
Lab Section
Sorting can be defined in terms of the grading permutation.

(x /: y) is (x) sorted into the order given by (y).  In other words, (y) gives the
sort keys for items of (x).  Formally, (x /: y) is  ((/: y) { x).

Note that both (x) and (y) can be arrays of any shape and type, as long as (x) has at least as many items as (y).

To sort a list, let the items of the list be their own keys, i. e.  (/:~ y).
This is equivalent to (y /: y).

To grade or sort in descending order, use (\:) instead of (/:).
)
/:~ 3 1 4 1 5 9   NB. Sort a list into order
\:~ 3 1 4 1 5 9   NB. Sort descending
]names =: 4 2 $ ;: 'Jones James Smith Philip Jones Howard Smith William'
]salaries =: 50000 60000 65000 70000
/:~ names   NB. The names, in order
salaries /: names   NB. The salaries, sorted into order by name

NB. /: /: y (grade twice) gives the ORDINAL NUMBERs of the items of y.
NB. That is 0 for the smallest item, 1 for the next-smallest, etc.
NB. It is a good exercise, and not so easy, to see that this is so.
/: /: 3 1 4 1 5 9

NB. ============================================================================
Lab Section The (i.) Family i. i: e. ~. ~: (x u/. y) [Searching]
J has a family of verbs that perform searches.  The basis of them all is
(x i. y) which gives, for each piece of (y), the index of the first matching item
in (x), or (#x) if no item of (x) matches.

Note that I said 'piece' of (y), not item.  That is because it is (x), the
table being searched, that specifies the rank of the pieces of (y).  (y) is
examined in pieces whose rank is the rank of an item of (x).  Formally, if
(rix) is the rank of an item of (x), the (rix)-cells of (y) are used as the
values to find in (x).  The shape of the result is the (rix)-frame of (y).
)
3 1 4 1 5 9 i. 4  NB. Look for 4; find it at item 2
3 1 4 1 5 9 i. 8  NB. Look for 8; don't find it; result is #x
3 1 4 1 5 9 i. 4 1 8  NB. Items of x have rank 0, look up each atom separately
]l =: i. 5 2  NB. A left argument of rank 2
l i. 6 7  NB. Items of x have rank 1, so this is 1 lookup
l i. 6  NB. y does not contain any items of x - error
]r =: 3 2 $ 6 7 2 1 4 5  NB. A right argument of rank 2
l i. r  NB. Each list in y is looked up in x

NB. ============================================================================
Lab Section
The other members of the (i.) family use (i.) as their basis.

(x i: y) is like (x i. y), but it gives the index of the LAST match, not the
first.  It still gives (#x) as the result if there is no match.

(x e. y) is  ((#x) ~: y i. x), in other words 1 if the piece of (x) is contained in (y), 0 if
not.  Note that in (x e. y), (y) contains the table and each piece of (x) is tested
for inclusion in (y).

(~. y) is the NUB of (y), defined to be the unique items of (y), in the order
in which they first appear in (y).

(~: y) is the NUB SIEVE of (y): a list, with one atom for each item of (y), whose
value is 1 for each item that is different from all earlier items of (y).
((~: y) # y) gives the same result as (~. y).

(x u/. y) first examines (x) to find the unique items; then  creates a PARTITIONING, which assigns each item of (x) into an array corresponding to which of the unique items it matches; then partitions (y) by assigning each item of (y) to an array following the partitioning of (x); then applies (u) to each partition of (y) and assembles the results of each partition into the overall result.  The partitions are visited in the same order as given by (~. x); within each partition, the items of (y) preserve their order; the rank of each partition is the rank of (y).

The (i.) family has the most heavily optimized code in the J interpreter and
you should use it whevever possible.
)
3 1 4 1 5 9 i: 1  NB. The last matching index
2 3 4 e. 3 1 4 1 5 9  NB. For each x, is it in y?
~. 3 1 4 1 5 9  NB. Unique elements of y
~: 3 1 4 1 5 9  NB. A mask that designates the unique elements
1 2 1 2 2 3 </. 3 1 4 1 5 9  NB. box each partition

NB. ============================================================================
Lab Section (x E. y) [Match Pattern]
(x E. y) looks for parts of (y) that match x.  The result is a Boolean array
that has the same shape as (y); each atom of (y) is 1 if (x) matches the subarray of
(y) for which that atom is a starting corner.
)
'th' E. 'three things hath thy father'  NB. Find places where x matches y
]r =: 4 4 $ 0 1 2 3  3 0 1 2  2 3 0 1  1 2 3 0  NB. An argument
2 3 E. r   NB. x must have the same rank as y
(,:2 3) E. r  NB. Make x rank 2, then find matching places in y
]l =: 0 1,:3 0  NB. The left argument
l E. r   NB. Find places matching this array

NB. ============================================================================
Lab Chapter Modifiers
NB. ============================================================================
Lab Section Introduction
Conjunctions and adverbs are MODIFIERS.

Modifiers operate on one or two OPERANDS which can be verbs or nouns.

A modifier consumes its operands and produces a new entity.  The
entity can be any part of speech.  Usually it is a verb, as it will
be in the examples we discuss here.

Verbs act on noun arguments to produce nouns; modifiers act on noun/verb operands to produce noun/verb/adverb/conjunctions.

A conjunction (c) has two operands, found before and after the conjunction,
as in (u c v).  (u) and (v) are the operands.

An adverb (a) has one operand, found before the adverb, as in (u a).

Named entities can be modifiers as well as verbs and nouns.  You must
know the part of speech of the names in a sentence before you can
understand the sentence.
)

NB. ============================================================================
Lab Section What a Conjunction Does Not Do
An example: the description of (&:) gives, for the dyadic case,

x u&:v y   is   (v x) u (v y)

This is a schematic description only!  The interpreter DOES NOT
actually expand the sequence (x u&:v y)  into  ((v x) u (v y)).

The interpreter could have been designed that way, with each name replaced
by an equivalent.  There are several reasons that would be bad design:

1.  There might not be a concise equivalent for the function of the
conjunction.

2.  At the time (u&v) is encountered, it is not known whether the
usage is monadic or dyadic, so both forms must be substituted;
but this can lead to huge intermediate results.

3.  Conjunctions are not required to have (x) and (y) arguments.  Substituting
the description of what the conjunction does to (x) and (y) doesn't make
sense if it doesn't have an (x) or (y).
)
PREPARE
4!:55 'a';'b';'c';'d'
odisp =: 9!:2''
9!:3 (5)
PREPARE
NB. Model for substituting &: symbolically
NB. Just to show how big the intermediate results can get
and =: 2 : 0
u @: v  NB. Monadic form
:
(u@[) v (u@]) NB. Dyadic form
)
a and b
a and b and c
a and b and c and d

NB. ============================================================================
Lab Section What a Conjunction Does
x u&:v y   is   (v x) u (v y)

means that (u&:v) produces a verb, and that verb operates according to the
description ((v x) u (v y)).  The verb created by execution of a conjunction
is called a DERIVED VERB.

The proper way to think of this is that (&:) itself is executed when it is
given its (u) and (v) operands.  Execution of (&:) produces a derived verb.
Execution of (&:) itself DOES NOT look at the (x) and (y) arguments.  [It can't - they might be nowhere to be seen, as in

xlonger =: >&:#

where the derived verb is assigned to a name.  (x) and (y) come along later.]

To repeat: in    (x u&:v y), (u&:v) is executed to produce a derived verb, and
then (x derived-verb y) is executed to produce the result of the expression.
)
PREPARE
9!:3 odisp
PREPARE

NB. ============================================================================
Lab Section
EXECUTION OF A CONJUNCTION PRODUCES A DERIVED ENTITY.

Some ramifications of this fact:

1.  You can assign the derived verb to a name.  When the named verb is
executed, the conjunction is not executed again - it was executed before
the verb was assigned.

2.  Any setup calculation done when the conjunction is executed does not
have to be done again when the verb is executed.

3.  The derived verb may use any algorithm it wants to produce a result
consistent with its definition.  Many of the fast idioms in J are
special combinations which are detected when a derived verb is created.
The derived verb then uses fast code to produce the correct result.
)
3 +&*: 4
addsq =: +&*:  NB. Assign derived verb to name
addsq          NB. Description of the derived verb
3 addsq 4

NB. ts displays the time and space used by a sentence
ts =: 6!:2 , 7!:2@]
array =: i. 1000000  NB. Define a big array
array i. 12345 67890  NB. Look up a couple of items

NB. Now compare the speeds of two different ways of lookup
ts 'array&i. 12345 67890'
lookarray =: array&i.
ts 'lookarray 12345 67890'

NB. Quiz: explain why the second form is so much leaner than the first,
NB. even though they have exactly the same function

NB. ============================================================================
Lab Section Adverbs
Everything that has been said about conjunctions applies to adverbs as well.

The only difference is that an adverb has only one operand, i. e.
it is executed as (u a) [no (v) operand].
)
NB. Answer to quiz in the previous section:

NB. The execution of array&i. creates an index of array for use in
NB. subsequent searches.  In the sentence
NB.   ts 'array&i. 12345 67890'
NB. array&i. is executed to create the derived verb, and the derived verb
NB. is then executed, and the time for both steps is measured.  In
NB.   lookarray =: array&i.
NB.   ts 'lookarray 12345 67890'
NB. the execution of array&i., including the time to build the index,
NB. happens when lookarray is defined.  The execution of the derived verb
NB. is fast.

NB. ============================================================================
Lab Section Incomplete Conjunctions are Adverbs
If you supply just one operand to a conjunction, you get a modifier
that needs one more operand to be executable.  That sounds like an
adverb, and indeed it is an adverb.  You should enclose the
conjunction/operand pair in parentheses if there are other elements
in the sentence.

Supplying one operand to a conjunction to make an adverb is analogous to
supplying one verb operand to a dyadic verb to make a monad, using
(m&v) or (u&n).
)
onpiecesusinghead =: ;.1  NB. Define adverb
# onpiecesusinghead  NB. Applied to a verb, creates derived verb
# onpiecesusinghead '*abcd*ab*def*a'

NB. Define a compound adverb, three adverbs in a row
onboxedpiecesusinghead =: (<@) onpiecesusinghead (;@:)
NB. See the derived verb when an operand is given
}. onboxedpiecesusinghead  NB.
NB. Example of use
}. onboxedpiecesusinghead '*abcd*ab*def*a'

NB. Alternative definition
onboxedpiecesusinghead2 =: 1 : ';@:(<@u;.1)'
}. onboxedpiecesusinghead2

NB. ============================================================================
Lab Section Invisible Modifiers: Hooks and Forks
Hooks and forks are modifiers that don't have a symbol.
They are recognized by syntax.

When a hook or fork is encountered, it is turned into a derived verb.

The HOOK is a sequence of 2 verbs in a row with no noun argument, as in
(f g)

The FORK is a sequence of 3 verbs in a row with no noun argument, as in
(f g h)

The verb derived from the hook has the function
 y f g y [monad]             x f g y  [dyad]

The verb derived from the fork has the function
 (f y) g (h y) [monad]       (x f y) g (x h y) [dyad]

As with visible modifiers, many sequences of (f), (g), and (h) are
recognized as special, and handled by a derived verb with special code.
)
NB. Average of an array
(+/ % #) 3 4 5 6
(+/ 3 4 5 6) % (# 3 4 5 6)
NB. Verb to find average of an array
average =: +/ % #
average 3 4 5 6

NB. ============================================================================
Lab Section Multiple Modifiers: Right-to-Left Order
In a sequence of modifiers, such as
  a@b@c
each modifier's left operand stops with a closest noun or verb that
does not have a conjunction to its left.  So, the sequence given above
would be executed as
  (a@b)@c

This order can be changed with parentheses.

Note that this parsing order, which produces left-to-right execution
of the conjunctions, corresponds to right-to-left execution of the
individual verbs when the derived verb is applied to x and y
arguments: c then (b then a).
)
2&+ @ +:   3 4  NB. Double, then add 2
+: @ 2&+   3 4  NB. Add 2, then double?  Why not?
NB. It was executed as (+:@2) & +
NB. but +:@2 is meaningless
+: @ (2&+) 3 4  NB. Add 2, then double

NB. ============================================================================
Lab Section The modifier (u/ y) [Insert]
(u/) is the modifier (/) applied to a verb (u).  When applied to
a noun (y), (u/ y) looks at (y) as a list of its items, and applies
the dyad (u) between the last two items; then applies (u) again between
the third-last item and the result of the first operation; and so on,
applying (u) (((#y)-1)) times, ending with the first item.  If we
number the items of (y) as (y0), (y1), etc., that means that (u/ y) is simply

y0 u y1 u y2 ... u yn

If there is only one item in (y), (u/ y )is just ({. y) (the result is the
sole item).

If (y) has no items, (u/ y) is the IDENTITY ELEMENT for (u).

(+/ y) produces the sum of the items of (y).
)
+/ 3 1 4 1 5 9   NB. Sum of the numbers
i. 3 4  NB. A 3x4 array (3 items)
+/ i. 3 4  NB. Sum the items, producing a list of 4 numbers
i. 1 4  NB. An array with 1 item (the item is a 4-element list)
+/ i. 1 4   NB. Result is a 4-element list
$ +/ i. 1 4   NB. Note the result has shape 4, NOT 1 4
+/ 0$0  NB. Sum of 0 elements is the identity element for +

*./ 1 1 1 1 NB. *. is Boolean AND; this is 1 if all items are 1
*./ 1 1 0 1

NB. ============================================================================
Lab Section The modifiers (u~ y) [Reflexive] and (x u~ y) [Passive]
(x u~ y) is defined as  (y u x).

In other words, (x u~ y) switches the left and right arguments and passes
them to (u).

This can be useful to save some parentheses, or in combination with other
modifiers.


(u~ y) is defined as (y u y).

In other words, (u~ y) duplicates its (y) argument as (x) and executes (u) as a dyad
with the two identical arguments.
)
5 -~ 3  NB. Same as 3 - 5
2 %~ 4 + 6   NB. Same as (4 + 6) % 4  (remember right-to-left!)

*~ 1 2 3 4  NB. Same as 1 2 3 4 * 1 2 3 4
#~ 1 2 3  NB. Same as 1 2 3 # 1 2 3

NB. ============================================================================
Lab Chapter Monads and Dyads
NB. ============================================================================
Lab Section Valence is a Property of Each Individual Use of a Verb
Every verb exists in two versions, the monadic and dyadic valences.

When you use a verb, the monadic or dyadic version will be selected
according to the context of the sentence in which the verb appears.
)
4.5 <. 5.5  NB. Dyad <. means 'lesser of x and y'
4.5 * <. 5.5  NB. Here <. is the monad, meaning 'next-lower integer'

NB. ============================================================================
Lab Section Be Careful of Valence in Hooks and Forks
When you are writing linear sentences, you can see at a glance what the valence
of each verb invocation is.

When you throw hooks and forks into the mix, the valences are not obvious.
A common error is to think that a verb will have one valence when it actually
has the other.

Remember: in any hook (f g), f is applied dyadically, g monadically.

in a fork (f g h), g is always applied dyadically, and f and h are applied
dyadically if the fork is applied dyadically.

If either the x or the y argument must be applied to two verbs, you cannot
use a hook - you need a fork.
)
NB. We want a verb pref that takes two character strings x and y and returns
NB. The starting characters of y, for as many characters as there are
NB. characters in x.  So, 'abc' pref 'xyzw' should be 'xyz'.
pref =: # {.  NB. # = count of characters, {. = take that many characters
'abc' pref 'xyzw'  NB. What happened?
NB. pref is a hook, so 'abc' (# {.) 'xyzw'  is   'abc' # {. 'xyzw'
NB. which is 'abc' # 'x'   which is a domain error.
pref =: # {. ]   NB. Try again
'abc' pref 'xyzw'  NB. What happened?
NB. pref is a fork, so 'abc' (# {. ]) 'xyzw'  is
NB. ('abc' # 'xyzw') {. ('abc' ] 'xyzw')    which is a domain error on #
NB. The problem is that we want to apply # monadically
pref =: ({.~ #)~  NB. Switch arguments, then apply the hook
'abc' pref 'xyzw'   NB. How did that work?
NB. 'abc' ({.~ #)~ 'xyzw'  is
NB. 'xyzw' ({.~ #) 'abc'   is
NB. 'xyzw' {.~ # 'abc'   is
NB. 'xyzw {.~ 3  is
NB. 3 {. 'xyzw'

NB. ============================================================================
Lab Section Using a Monad in a Dyad's Place: (@]) and (@[)
In the preceding example we needed to apply (#) to just one argument.  We saw
one solution: using (~) to fiddle with the argument order so as to put
the left argument into the right argument of a hook, where the verb that
operates on it is used monadically.

Code full of (~) is hard to read, and the trick doesn't work for complex verbs.
If you want to apply a verb to just one of the two arguments it is given,
the better solution is to use ([) and (]) to select the argument you need.

(x u@] y)  is  (u x ] y) which is (u y).   In other words, the (x) argument
has been discarded and (u) is applied to (y) alone, even if the overall verb
(u@]) is given both (x) and (y).

Similarly, (x u@[ y) is (u x).
)
pref =: #@[ {. ]
'abc' pref 'xyzw'   NB. # is applied only to 'abc', giving the desired result

NB. ============================================================================
Lab Section Using a Dyad in a Monad's Place: (m&v) and (u&n)
You might want to perform a dyadic function in a place where your
verb is invoked as a monad.

In such a case, since the dyadic verb needs two arguments and the monadic
context is going to supply only one, the other argument to the dyad must
somehow be specified inside the monad.

You attach the other argument to the dyad with the (&) conjunction.
(m&v y) is (m v y), in other words (m&v) is a monad that executed dyadic (v)
with the arguments (m) [part of the verb (m&v)] and (y), the operand to the monad.

Similarly, (u&n y) is  (y u n).  So you choose (m&v) to make (m) the left argument
of the dyad, or (u&n) to make (n) the right argument.

Some examples of when you need a monad to do a dyad's work:

1.  The function you want is only monadic, as in the dual function (u&.v).
(v) is a monad, so if you need two arguments to (u), you have to use (m&u) or (u&n).

2.  You need to inject an argument into a long verb.  A simple example
is  ((x&u)&.v).  This is like (x u&.v y) except that in ((x&u)&.v) the
(x) argument bypasses the verb (v).  This is necessary if the verb (v) is
inappropriate for (x).

3.  Another example: ((f g m&h) y).  Here (h) must be monadic, since
it is in a monadic fork, so the only way to pass in the argument is with
(m&h).

4.  Another example: (x (f g (m&h)@]) y).  The verb (h) is turned into
a monad and then back into a dyad with a different argument.  We want
(m h y) instead of (x h y), so first we ignore (x) with (@]) and then
supply (m) with (m&).
)
2 3 %&(1&{) 5 6 7  NB. (1 { x) % (1 { y)
(+/ % #)@:(2 3&{)&.:*:  3 1 4 1 5 9  NB. Geometric mean of items 2 and 3
2 ({ - 1&{@]) 3 1 4 1 5 9  NB. Difference between item x and item 1

NB. ============================================================================
Lab Section Alternative to (m&v) and (u&n): Constant in Fork
Another way of putting a fixed argument into a verb is with the CONSTANT FORK

(noun verb verb)

Instead of the usual fork (f g h) where f g h are verbs, in the constant
fork f is a noun and g and h are verbs.  In this context, the noun
acts like a verb with no arguments: it just produces itself as its
result.

So, the form  (x (f g m&h@]) y) could be written

x (f g m h ]) y

because (m h ]), the constant fork, is equivalent to (m&h@]).

The choice between (m&v) and (m v ]) is simply a matter of taste.
Note that (verb verb noun) is not a constant fork - it is just two
verbs applied to a noun, producing a noun - so to replace
(u&n) you need to write (n u~ ]).
)
2 ({ - 1&{@]) 3 1 4 1 5 9  NB. Version using &
2 ({ - 1 { ]) 3 1 4 1 5 9  NB. Version using constant fork

0.1 (0&>.)@:(1&<.)@:*  _10 _5 0 4 8 12 16   NB. Clamp x*y between 0 and 1
0.1 (0 >. 1 <. *) _10 _5 0 4 8 12 16  NB. Version using constant fork

1 3 5 7 (i.&1)@:= 3 4 5 6   NB. Find index of first equal items
1 3 5 7 (1 i.~ =) 3 4 5 6  NB. Version using constant fork

NB. ============================================================================
Lab Section The Capped Fork
The verb ([:) is an odd animal.  In its most frequent use it is never
even executed at all: this is the CAPPED FORK

([: g h)

This is fundamentally different from the normal fork
([x] (f g h) y) which is  (([x] f y) g ([x] h y)).  The capped fork
([x] ([: g h) y) is   (g ([x] h y)).

([: g h) is equivalent to (g@:h).

In the capped fork, g is executed as a monad; in the normal fork,
it is a dyad.  The capped fork is special syntax, a new combination
in addition to the hook and normal fork.  Its behavior is NOT explainable
as the result of ([:), because ([:) is never executed.

Whether you use ([: g h) or (g@:h) is a matter of taste.
)
pref =: #@[ {. ]   NB. Using @
pref =: ] {.~ [: # [  NB. Using capped fork

NB. ============================================================================
Lab Section Univalent Verbs; the Suicide Verb ([:)
If the verb ([:) is actually executed, it results in a domain error.
This is the fastest way to generate an error in a part of a verb you don't
want to be executed.

The most frequent use of ([:) is in the form  (u : [:) or ([: : v).

The conjunction (u : v) creates a verb whose monadic valence is 
(u)
and whose dyadic valence is (v).  In other words, (x (u : v) y) is (x v y), while ((u : v) y) is (u y).

When ([:) is specified for a valence,
it guarantees that the verb will fail if invoked with that valence.
You can use this to ensure that verbs are not invoked improperly.
)
[: 5    NB. Always a domain error
5 [: 6
3 4 5 6 (1 + i.) 3  NB. One more than the matching index
IndexPlusOne =: 1 + i.
3 4 5 6 IndexPlusOne 3
IndexPlusOne 1 2 3  NB. Oops, we invoked it as a monad
IndexPlusOne =: [: : (1 + i.)   NB. Make the monadic case fail
IndexPlusOne 1 2 3  NB. Now we get an error

NB. ============================================================================
Lab Chapter Rank in Compounds
NB. ============================================================================
Lab Section How Is (@) Different From (@:)?
The conjunctions (@) and (@:) are almost identical.

[x] u@:v y   is   u [x] v y

[x] u@v y    is   [x] (u@:v)"v y

(u@:v) has infinite rank, while (u@v) has the ranks of (v).  What is the practical
difference?

Let (rv) be the rank of (v).  In either verb, (v) operates on cells of rank (rv).
In (u@v), the overall verb (u@v) also operates on cells of rank (rv).
This means that the (rv)-cells of the argument are processed independently
by the overall verb.

Use dissect on these sentences to follow the execution.  For u@v you must select a single result-cell before you can see the result of v that contributed to it.
)
+/@:*:  1 2 3   NB. Sum of squares
(+/@:*:)"0  (1 2 3)  NB. With rank 0, each atom is independent.
+/@*:  1 2 3   NB. +/@*:  is equivalent to   +/@:*:"0

NB. ============================================================================
Lab Section Interpretation of (u@v)
Many J users explain the difference between (@) and (@:) like this:
in (u@:v), (v) executes and passes its entire output to (u), while in (u@v),
each output cell of (v) [i. e. the result of processing one cell] is
passed to (u).

This interpretation will work for simple cases, but it is not accurate, for two reasons:

1. the control of what gets passed to (u), (v), and (u@v) is done not inside (v), but in a part of (u@v) that is outside of both (u) and (v);

2.  it gives incorrect results when applied to sequences of more than two verbs.

The more accurate interpretation is that (u@v) has the rank of (v), which means
that the overall verb (u@v) is applied to (rv)-cells of the arguments [by which
we mean cells of the rank indicated by the ranks of (v)]. Since (u@v) is applied
to each (rv)-cell, it follows that (u) will operate on an output cell of (v).
)

NB. ============================================================================
Lab Section Sequences of (@) and (@:)
A sequence of verbs can be concatenated using many different
combinations of (@) and (@:), and the combinations usually produce
different results.  You need a way to analyze such sequences.

To succeed, pay attention not just to the individual concatented verbs,
but to the sequence of compound verbs.  Each compound verb has a rank that
determines the size of its cells; these cells are then processed by the
verbs in the compound.
)
NB. 5!:6 <'name' will show you the fully-parenthesized representation of
NB. a name.
nm =: +@:-@*@:%
nm
5!:6 <'nm'

NB. ============================================================================
Lab Section Exegetic Examples
We will now follow some examples of compounds.

For each example, use dissect to give a detailed picture, and click in any result cell to highlight the inputs that went into its calculation.
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The argument we use for the examples

NB. Example 1.    }.@:({.@>) a


NB. The outermost verb is (}.@:({.@>)) which has rank _ because it
NB. uses @: .  So ({.@>) is applied to the entire a.  This has rank
NB. 0 because of @, so > then {. is applied to each cell, giving 1 4 6.
NB. Then }. is applied, leaving 4 6.

}.@:({.@>) a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The argument we use for the examples

NB. Example 2.    }.@({.@>) a

NB. The outermost verb is (}.@({.@>)) which has rank 0 because it
NB. uses @ and the rank of {.@> is 0 (from >).  So (}.@({.@>)) is applied
NB. to 0-cells of a independently.  On each 0-cell, ({.@>) is applied
NB. first, which opens the cell and then keeps just the first item,
NB. and then }. is applied which deletes that one item, leaving an
NB. empty list.  Each cell produces an empty list, so the result is
NB. an array of shape 3 0, which display as three blank lines.

}.@({.@>) a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The argument we use for the examples

NB. Example 3.    }.@:{.@> a
tv =: }.@:{.@>
5!:6 <'tv'

NB. The outermost verb is (}.@:{.)@> which has rank 0 (from >) because it
NB. uses @ .  So (}.@:{.)@> is applied to 0-cells of a independently.
NB. The processing follows the same path as example 2: on each cell
NB. >, then {., then }., result 0 3$0 .
NB.
NB. Note that replacing the @: by @ would not affect the result.
NB. }.@{. is equivalent to }.@:{. because both compounds have rank _ .

}.@:{.@> a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The argument we use for the examples

NB. Example 4.    }.@({.@:>) a

NB. The outermost verb is }.@({.@:>) which has rank _ (from {.@:>)
NB.  So }.@({.@:>) is applied to the entire a.  ({.@:>) is
NB. applied first.  It has rank 0 and so it too is applied to the
NB. entire a.  First a is opened, producing a 3x3 array; then the
NB. first item of that is taken, leaving 1 2 3 .  }. is applied
NB. to that, leaving the result 2 3 .

}.@({.@:>) a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The argument we use for the examples

NB. Example 5.    {.@>@}. a
tv =: {.@>@}.
5!:6 <'tv'

NB. The outermost verb is ({.@>)@}. which has rank _ (from }.)
NB. So ({.@>)@}. is applied to the entire a. }. is applied first,
NB. leaving (4 5 ; 6 7 8).  {.@> is applied to this.  {.@> has
NB. rank 0 (from >), so it is applied to 0-cells of (4 5 ; 6 7 8)
NB. independently.  Each one is opened and then the first item
NB. is taken, leaving the result 4 6 .

{.@>@}. a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The argument we use for the examples

NB. Example 6.    {.@:>@}. a
tv =: {.@:>@}.
5!:6 <'tv'

NB. The outermost verb is ({.@:>)@}. which has rank _ (from }.)
NB. So ({.@>)@}. is applied to the entire a. }. is applied first,
NB. leaving (4 5 ; 6 7 8).  {.@:> is applied to this.  {.@> has
NB. rank _ (from @:), so it is applied to the entire (4 5 ; 6 7 8).
NB. Opening that list produces the array (2 3 $ 4 5 0  6 7 8), because
NB. the short item is padded with fill.  The first item of that is taken,
NB. leaving 4 5 0.

{.@:>@}. a

NB. ============================================================================
Lab Section Guidelines For Using (@) and (@:)
Your practice should be to use (@:) for function composition unless you
have thought matters through and are sure that (@) is what you really
need.

It is almost never right to use (@) when (v) is an arithmetic operation.
Something like (+:@-) will apply the compound on each atom
independently, which will be much slower than (+:@:-) which works
on the entire array.

(@>) is used to operate on individual box contents.  (@:>) will
fail if the contents have dissimilar types, and will add fill if they
have dissimilar shapes.

Generally, (u@:> y), (u&:>), and (u&.:>), which all apply (> y) to the entirety of (y), indicate a mistake; for if there were no problem in opening the boxes of (y) and assembling them into an array before applying (u), why did you box (y) in the first place?
)

NB. ============================================================================
Lab Section Other Conjunction Pairs (& &:)  (&. &.:)
The principles used to make sense of (@) and (@:) also apply for other
ways of making compounds.  The conjunction (&:) is defined by

[x] u&:v y   is   [v x] u (v y)

and this is used to define (&) as

[x] u&v y    is   u&:v"mv   [mv is the monadic rank of v]


Similarly, (&.:) is defined as

[x] u&.:v y   is   (u^:_1) [v x] u (v y)

and this is used to define (&.) as

[x] u&.v y    is   u&.:v"mv
)
_1 2 _3 4 5 i.&:|   _4 2   NB. Take absolute value, then look for y in x
_1 2 _3 4 5 i.&|   _4 2   NB. Rank 0 makes no sense

+/&.:*: 1 2 3   NB. Square root of sum of squares
+/&.*: 1 2 3   NB. As rank 0, a silly operation

NB. ============================================================================
Lab Chapter Concatenation
NB. ============================================================================
Lab Section Verbs for Concatenation
A number of verbs concatenate two arguments.  They are:

(x , y) [append]
(x ,. y) [stitch]
(x ,: y) [laminate]
(; y) [raze]

These verbs are all variations on the same basic function.
)

NB. ============================================================================
Lab Section Raze, the Prototype for Concatenation
(; y), the verb called Raze, is the general case of concatenation.
We will examine it and define the other verbs as special cases.

(; y) is an extension of (, y).  (; y) first puts the atoms of (y) into a list; then, if the atoms of (y) are boxes, each box is opened and the resulting contents concatenated to produce the result.  The definition of 'concatenated' is rather complex in general, because the items of the different boxes may have different shapes; but in the simple case, when all the contants have items of the same shape, concatenation is striaghtforward: the result is an array whose items are the items of all the contents, in order.

Since it is the contents
of the boxes that are concatenated, the actual shape of the boxed argument is
immaterial except to indicate the order in which the contents are
concatenated.

For example, if (i. 2 3) with
item shape (,3) is concatenated with (i. 5 3) with item shape (,3), the
result has items of the same shape - (,3) - and so the result shape is
(7 3), with 2 items from (i. 2 3) followed by 5 items from (i. 5 3).

If the contents of the boxes have items of different shapes, the situation
gets more complicated.
)
(i. 2 3) ; (i. 5 3)  NB. Two boxes
; (i. 2 3) ; (i. 5 3)  NB. Contents concatenated

NB. ============================================================================
Lab Section Raze Overview
Some observations to help you follow the detailed description of raze:

1.  Smaller items are padded to match the shape of the largest item.  For items that are arrays, fill atoms are used for the padding.
Note: ITEMS of the boxed contents, not the whole boxed contents.  The items
are brought up to common shape, and then the items of the several contents
are concatenated into one long list of items.
)
NB. Examples of raze:
]op =: 2 ; 5
;op
]op =: 2 3 ; 5  NB. Items are atoms; no extension
;op
]op =: (i. 3 3) ; i. 2 2   NB. Short item is extended
;op

NB. ============================================================================
Lab Section
2.  Atoms, however, are not padded with fill; their values are replicated
as required to match the shape of the largest item.  Also, they do not affect the size of the items of the result.
The size of an item of the result is calculated by looking at all the
contents that are arrays, and then each atom is replicated to
produce a single item of that size.
)
]op =: (i. 3 2) ; 9   NB. Atom is replicated
;op
]op =: (i. 2 3) ; (i. 2 2) ; 6   NB. Atom is replicated; short list padded
;op

NB. ============================================================================
Lab Section
3.  If the contents have different ranks, the lower-rank arrays are brought up
to the rank of the largest-rank contents by adding leading axes, of
length 1, as many times as needed.  So, a contents of shape 3 4 will
be treated as having shape 1 3 4 if the largest contents has rank 3, or
1 1 3 4 if the largest contents has rank 4, and so on.  Note that there
is no replication or padding: the shape is changed, but not the number of
atoms in the array.

The extension of rank happens first thing, before the items are padded
with fill.

As with padding, atoms do not participate in this extension of rank.
An atom always becomes a single result item whose shape is determined
by the shape of the other elements.
)
NB. Atom is replicated; short list has axis added, then items are padded with fill
op =: (i. 2 3) ; 8 9 ; 6
;op

]op =: (i. 2 0 4) ; (i. 0 2) ; 6
NB. Watch this carefully: first (i. 0 2) has a leading axis added, to make it
NB. have shape (1 0 2).  The largest item shape is 0 4.  The atom is
NB. replicated to shape 0 4.  The items are run together, producing shape
NB. 4 0 4, an empty noun.  This will be analyzed in detail later.
;op
$;op  NB. See the shape

NB. ============================================================================
Lab Section
)
NB. See the difference between the atom 6 and the list ,6.  The
NB. difference comes from the extension of rank of the list ,6.
NB. The ,6 is rank-extended to shape 1 1 1, so items now have shape
NB. 1 4, and the items of (i. 2 0 4) and (i. 0 2) become visible.
NB. This is analyzed in detail later.
]op =: (i. 2 0 4) ; (i. 0 2) ; ,6
;op
$;op

]op =: (i. 2 0 4) ; 8 9 ; 6  NB. 8 9 is padded, atom 6 is replicated
;op

NB. ============================================================================
Lab Section Raze Details
The steps are as follows:

1.  The shape of the result items is calculated.  This is the the maximum,
for each axis independently, of the shapes of the items of the boxed
contents.  For this calculation, any box containing an atom is ignored,
and among the other boxes, shapes that are shorter than the shape of the
highest-rank contents are extended with 1s to the length of the longest shape.  If all the contents are atoms, the result item is also an atom.

2.  Each boxed contents is converted to a list of items each of which has
the result item shape.  Any contents that does not have rank higher than
the rank of the result item has its shape extended by adding 1s until it is
a list of 1 item of the correct rank; then the items are padded to the
result item shape.  Items are padded with fills as needed EXCEPT in the
case where the original contents was an atom: in that case, the atom is
replicated to the result item shape.

3.  The items of the contents, after having been brought to a common
rank and shape as described above, are concatenated to produce the final
result.

The following sections explore what ; does.
)

NB. ============================================================================
Lab Section
)
NB. Operation of ; (i. 2 3) ; 8 9 ; 6
]op =: (i. 2 3) ; 8 9 ; 6   NB. The argument
;op  NB. Result of raze
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring atoms
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand atoms by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp

NB. ============================================================================
Lab Section
More examples.
)
NB. Operation of ; (i. 2 0 4) ; (i. 0 2) ; 6
]op =: (i. 2 0 4) ; (i. 0 2) ; 6   NB. The argument
;op  NB. Result of raze
$ ;op  NB. The shape of the empty result
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring atoms
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand atoms by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp
$ > ,&.>/ , cp  NB. The shape of the empty result

NB. ============================================================================
Lab Section
More examples.
)
]op =: (i. 2 0 4) ; (i. 0 2) ; ,6
;op  NB. Result of raze
$ ;op  NB. The shape of the empty result
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring atoms
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand atoms by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp
$ > ,&.>/ , cp  NB. The shape of the empty result

NB. ============================================================================
Lab Section
More examples.
)
NB. Operation of ; (i. 2 0 4) ; (i. 2) ; 6
]op =: (i. 2 0 4) ; (i. 2) ; 6   NB. The argument
;op  NB. Result of raze
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring atoms
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand atoms by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp

NB. ============================================================================
Lab Section Other Verbs For Concatenation; Atoms
(,: y),  (,. y), (x , y),  (x ,. y), and (x ,: y) perform reshaping and concatenation.

Note that atoms are handled as special cases in most of these:

In (x , y) an atom is replicated to the shape of an item of the other
argument.

In (x ,: y) an atom is replicated to the shape of the entire other argument.

In (,. y) an atom is first turned into a one-item list.
)

NB. ============================================================================
Lab Section (x , y) [Append]
(x , y) concatenates the (x) and (y) arguments.  The result is the same as
; (<x), (<y).

The operation is easier to describe with only 2 arguments.

1.  Any atom argument is replicated to be the shape of an ITEM of the
other argument.  [This is simpler than the general case of (; y),
because there is no need to look through all the contents to find
the shape of a result item - with 2 arguments the result item will always
be the shape of an item of the other argument]

2.  If one argument has lower rank than the other, leading axes of length
1 are added to bring the arguments to the same rank.  This does not add
or remove atoms, it just reshapes the array.

3.  The items of the arguments, which now have the same rank, are brought
up to the same shape by padding with fills at the end of any axis that is
shorter than in the other arguments.

4.  The lists of items, which now have the same item shape, are concatenated.
)
(i. 2 3) , 6   NB. Item has shape ,3 so 6 is replicated
(i. 2 0 3) , 6  NB. Item has shape 0 3 so 6 is replicated to that shape...
$ (i. 2 0 3) , 6   NB. ...which gives one more item of shape 0 3, for 3 in all
(i. 1 3) , (i. 3 1)  NB. Result item has shape 3
(i. 2 1 3) , (i. 2 3 1) NB. Result has item shape 3 3, both arguments are padded

NB. ============================================================================
Lab Section Appending empty arguments
Concatenating arguments of dissimilar types produces a domain error.

The exception is if one of the arguments is empty.  An empty argument
is filled with fills of the correct kind for the result, so no error
occurs.

Any noun with no atoms is empty.  Another way of saying that is that
any noun with a zero in the shape is empty.

If two empty arguments are appended, the type of the result is the
larger of the two argument types.  The order of types is
boolean (low), character, integer, float, complex , extended, rational (high).
)
0 , ' '  NB. Dissimilar types
0 , ''   NB. Dissimilar types, but OK with one empty
(i. 2 3) , ''  NB. Dissimilar types, result is the nonempty type
(2 3 $ 'abcdef') , 0$0    NB. Dissimilar types, result is the nonempty type
3!:0 (0$0) , ''  NB. Result is numeric
3!:0 (0$1j1) , ''  NB. Result is complex

NB. ============================================================================
Lab Section (,: y) [Itemize] and (x ,: y) [Laminate]
(,: y) appends a leading axis of length 1 to the shape of (y), thus increasing the rank of (y) by 1.  We
have encountered this operation is our discussions of concatenation.  It
does not change the number of atoms in y.

(x ,: y) adds one leading axis to the arguments and then concatenates them.
It is equivalent to ((,: x) , (,: y)) after a preprocessing step for
atom arguments: if (x) or (y) is an atom it is first replicated to be the
shape of the other argument; additionally, if both arguments are atoms,
they are made into one-item lists.  Use (x ,: y) when you have
two arrays and you want each one to be an item of a new array, rather
than having their items run sequentially.
)
$ ,: i. 1 2 3   NB. shape extended
,: i. 1 2 3   NB. No atoms added
2 3 ,: 4 5  NB. Creates an array of higher rank
2 3 , 4 5   NB. Keeps the same rank
1 ,: 3 4 5  NB. atom argument is reshaped

NB. ============================================================================
Lab Section Monad ,. (Enfile Items) and Dyad ,. (Stitch)
,. operates on items of the argument(s).

(,. y) applies (, y) to each item, converting the item to a list.  The
overall result is a list of the resulting lists, which therefore has rank 2.
If the argument is an atom, it is given a shape of 1 1 .  So, the result
always has rank 2.

(x ,. y) is equivalent to (x ,"_1 y), in other words, items of (x) and (y) are
matched up and appended to each other to produce items of the result.
)
i. 2 3 4
,. i. 2 3 4   NB. Convert each 3x4 to a list 4
,. 2 3 4    NB. Convert each atom to a list, producing an array
$ ,. 9  NB. A single atom is also converted to rank 2

(i. 2 3) ,. (i. 2 3)  NB. Run the items together
8 9 ,. i. 2 3  NB. Left items are atoms, right items are list.  Append them

NB. ============================================================================
Lab Section Specifying a Fill Atom
The verbs for concatenation:
  (x , y) (x ,. y) (x ,: y) (; y)
all bring their arguments [or parts thereof] to a common shape by
padding with fills.

You can use the Fit conjunction to specify what will be used for the fill.

(x ,!.n y) (x ,.!.n y) (x ,:!.n y) (;!>n y) will use (n) for the fill.

Replicating an atom is not fill, and is not affected by Fit.
)
(i. 2 3) , 3 4  NB. 3 4 is padded to 3 items
(i. 2 3) ,!.99 (3 4)  NB. Use 99 for the fill cell
(i. 2 3) ,!.99 (3)   NB. Atoms are always replicated, not filled

NB. ============================================================================
Lab Section (x ; y) [Link: Append Boxed]
(x ; y) is    ((<x) , <^:(0 = L.) y)

The arguments are concatenated.  The (x) argument is always put into a box; the
(y) argument is pu tinto a box only if it was unboxed to begin with.

This asymmetrical definition causes an expression like

x ; y ; z

to box each argument exactly once if they were all unboxed initially.
This is usually what you want.  If (z) was boxed, and you want to add
a boxing level to it too, you must write

x ; y ;< z

to force boxing of the last item in the chain.

If you just want to add one level of boxing regardless of the initial
condition, use

x ,&< y
)
1 ; 2 3 ; 4 5   NB. Create a list of boxes
1 ,&< 2 3 ,&< 4 5   NB. ,&< is not usually what you want
(1 ; 2) ; (3 4 ; 4 5)  NB. Do you expect 2 boxes or 3?
(1 ; 2) ,&< (3 4 ; 4 5)  NB. One way to get 2 boxes
(1 ; 2) ;< (3 4 ; 4 5)  NB. Another way

NB. ============================================================================
Lab Chapter (^:) Power/If/Converge/DoWhile
NB. ============================================================================
Lab Section The Power Conjunction (^:)
The Power conjunction is easy to define.  (u^:n y) executes (u y) (n) times,
in other words it is    (u u u... [n times]... u y).

(x u^:n y) is equivalent to ((x&u)^:n y).  This is the same as
(x u x u ... [n times]... x u y).  Note that (x) stays unchanged during
the repeated execution of (u).

(u^:n) gets interesting when we interpret what it means for special values of (n).
)
>:^:2 ] 4 5  NB. Increment, twice
>:^:0 ] 4 5  NB. Increment, 0 times.  Doing anything 0 times leaves y unchanged
2 +^:3 ]4 5  NB. Add 2 three times
(2&+)^:3 ] 4 5  NB. Equivalent form

NB. ============================================================================
Lab Section n=0 [leave (y) unchanged] and n=1 [execute (u) once]
Executing a verb 0 times is no execution at all.  ([x] u^:0 y) is the same as
plain (y).

([x] u^:1 y) is the same as ([x] u y).

With (n) equal to 0 or 1, we have the idea of conditional execution:
([x] u^:n y) executes (u) if (n) is 1, but it leaves (y) unchanged if (n) is 0.

When (u^:n) is used with (n) guaranteed to be 0 or 1, we think of it as IF.
)
test =: 0
10 +^:test 5  NB. test is false, don't execute +
test =: 1
10 +^:test 5  NB. test is true, execute +

'left' [^:test 'right'  NB. If true, take x argument; if false, keep right
test =: 0
'left' [^:test 'right'

NB. ============================================================================
Lab Section (u^:v) - Data-Dependent Execution
The right operand of (^:) can be a verb.  We write that as (u^:v).
(u^:v) is defined in terms of (u^:n).  (v) is evaluated, and that value is
used as (n); (u) is then executed n times.  In other words,
([x] u^:v y) is equivalent to ([x] u^:([x] v y) y).

Using (u^:v), you can have the execution of (u) depend on the (x) and (y) data.


Points to note:

1.  (u^:v) can be used as either a dyad or a monad.  Whatever arguments there are will be applied to both (u) and (v).  Thus, if there is an (x) argument, both (u) and (v) will be executed as dyads.

2.  Often the (x) argument is just used to control the execution, i. e. it is needed only in (v).  In that case you will be prone to forget that it is also
an argument to (u).  If you want to ignore (x), make your (u) look like (u@]).

3.  You can give (u^:v) a rank, by writing (u^:v"r), to make the number
of executions of (u) vary from cell to cell.  This feature is the main reason that (^:) can be better than (if.) - it can produce different results for different cells.
)
If =: ^:  NB. Define a mnemonic
5 + If > 4  NB. 'add if greater'
5 + If > 6
1 3 5 (+ If >)"0 ] 2 3 4  NB. Make the test on each atom

1 0 1 0 0 +: If [  5 6 7 8 9  NB. Double if left argument is 1.
NB. What happened?  We applied 1 +: y, not +: y
1 0 1 0 0 +:@] If [  5 6 7 8 9  NB. Apply monad +:
NB. What happened?  We need to apply the verb on atoms of the argument
1 0 1 0 0 +:@] If ["0 (5 6 7 8 9)  NB. That's better

NB. ============================================================================
Lab Section (u^:_) [Converge]
([x] u^:_ y) means 'apply u an infinite number of times' which could
take a long time.  J stops applying (u) when the result stops changing.
)
-:^:_ (1)  NB. 1, 1/2, 1/4, 1/8...  limit is 0
NB. Newton's Method.  Define a function and its derivative.
func =: verb : '(3*y^3)+(2*y^2)-10'  NB. a polynomial...
deriv =: verb : '(9*y^2)+4*y'    NB. ...and its derivative
NB. Apply Newton's Method to converge on a solution
newton =: verb : 'y - (func y) % (deriv y)' ^:_
newton 3

NB. ============================================================================
Lab Section (u^:v^:_) [DoWhile]
(u^:v), when (v) produces a Boolean, means 'execute (u) if (v) is true'.

(u^:_) means 'execute (u) until the result stops changing'.

Put these together in the form  (u^:v^:_) and you have
'execute (u) repeatedly, as long as (v) is true [and the result changes]'

In other words, you have 'execute (u) while (v) is true', which in C syntax is

while(v(y))y = u(y);

(u^:v^:_) is an expression rather than a statement, so it can be embedded
in a larger sentence, and it can be given a rank so that different
cells have different numbers of iterations.
)
NB. u is +: (double);  v is <&200  (less than 200); so
NB. +:^:(<&200)^:_ means 'double until the result is not less than 200'.
NB. We want to apply this verb to each atom independently, so we give
NB. it rank 0:
+: ^: (<&200) ^: _ "0  i. 6
NB. Each number is doubled until it stops changing (0) or gets to 200.

NB. ============================================================================
Lab Section (u^:n) when (n) is an array
When (n) is an array, (u^:n) is evaluated for each atom of (n), and the
results are assembled into an array using the shape of (n) as the frame.

The same is true in (u^:v) if (v) produces an array.
)
+:^:1 2 3 (2)  NB. Double 1, 2, and 3 times.  Result is a list
+:^:1 2 3 (0 1 2)  NB. Applied to a list, the result is a rank-2 array
+:^:(,0) i. 2 3  NB. +: is not applied, but...
$ +:^:(,0) i. 2 3  NB.  ...the result has an axis added.

NB. ============================================================================
Lab Section (u^:(<n)) Save Intermediate Results
When (n) is boxed, as in (u^:(<n)), it means to execute (u^:n) but
save all the intermediate results, as if the operation were
(u^:(i. n)).

The interesting case is (u^:(<_)), which executes as (u^:_), in other words
execute until the result stops changing.  The result of (u^:(<_)) is
the list of all the results of repeated evaluation of (u).  The last two
items of the result will necessarily be the same.

(u^:a:) gives the same result as (u^:(<_)).
)
NB. Newton's Method, displaying the results of each iteration
func =: verb : '(3*y^3)+(2*y^2)-10'  NB. a polynomial...
deriv =: verb : '(9*y^2)+4*y'    NB. ...and its derivative
NB. Apply Newton's Method, keeping the intermediate results
newton =: verb : 'y - (func y) % (deriv y)' ^:a:
newton 3

NB. ============================================================================
Lab Section (u^:n) Gerund Forms of Power
Gerund forms of (^:) are available.  They are used only for writing tacit code.

(x u^:(f`g`h) y)  is  ((x f y) u^:(x g y) (x h y))
   same as (x (f u^:g h) y)

(x u^:(g`h) y)  is  (x u^:(x g y) (x h y))
   same as (x ([ u^:g h) y)

(u^:(g`h) y)  is  (u^:(g y) (h y))
   same as ((u@]^:(g@[) h) y)
)

NB. ============================================================================
Lab Chapter Inverses
NB. ============================================================================
Lab Section (^:_1) [Inverse]
If (u^:1 y) means execute (y) once, and (u^:0 y) means execute (y) not at all,
what does (u^:_1 y) mean?  How can you execute something less than once?

You apply the inverse of (u).  The inverse (i) [called the OBVERSE in most
of J literature] is a function that is undone by (u): (u i y) gets you
back to (y).

(u^:_2) y means apply the inverse twice, and so on.
)
>:^:(_2 _1 0 1 2) 100  NB. Increment _2 etc. times
'a' ,^:(_2 _1 0 1 2) 'wxyz'  NB. Prepend 'a' _2 etc times.
NB. Note that the inverse of adding 'a' is removing one character.

NB. ============================================================================
Lab Section System-Defined Inverses
Many verbs - more than you would expect - have inverses that can be
applied using (u^:_1).  To see if a verb (v) has an inverse, type

v b. _1

The result will be the inverse, if any, as a character string.  If there
is no defined inverse you will get a domain error.

Note that the inverse is defined only for the monadic form of a verb.
If you want the 'dyadic inverse', which would be the function (i) such
that (x u x i y) gets you back to (y), you can take the inverse of
(x&u).
)
>: b. _1  NB. Inverse of >:
2&* b. _1
, b. _1  NB. No way to invert that!
,&'a' b. _1  NB. But it is possible to invert adding an item to the end
+:@:*: b. _1  NB. The operation is 'square then double'
+/\ b. _1  NB. The operation is 'running sum'.  Clever, eh?

NB. ============================================================================
Lab Section User-Defined Inverses
You can supply the inverse for a verb that lacks one: it might be a verb
you wrote, or it might be a verb whose inverse is valid only in a
restricted domain that you happen to know you will be using.

The verb

u :. v

executes just like (u) except when its inverse is called for: then, (v) is
used for the inverse.
)
NB. There is no inverse for -~/\
-~/\ b. _1
NB. We can create one and associate it with -~/\
runningrevdiff =: -~/\  :.  (((+ +/),])/&.|.)
NB. May it take you less time to understand that inverse than it took
NB. me to find it!

NB. We can use it to undo the runningrevdiff verb
runningrevdiff 2 3 4 5 6 7
runningrevdiff^:_1 (2 1 _1 _4 _8 _13)
runningrevdiff^:(2) 1 1 2 3 5 8 13 21 34
1 _1 _1 _2 _2 _2 _1 1 5
runningrevdiff^:(_2) 1 _1 _1 _2 _2 _2 _1 1 5
1 1 2 3 5 8 13 21 34

NB. ============================================================================
Lab Section Dual (u&.v) and (u&.:v)
Why would you go to the trouble of defining (f =: u :. v) and
then writing (f^:_1) when you could just as easily write (v)?

You wouldn't.

The power of the inverse is in its use in the form (u&.:v) and (u&.v),
which are called DUAL in J.

 ([x] u&.:v y) is (v^:_1 [v x] u (v y))
 ([x] u&.v y) is  ([x] u&.:v"mv y) [rank is the monadic rank of (v)]

(u&.:v) applies (v) to each argument, then performs (u), then applies the
inverse of (v).

This is a tool of extraordinary economy and expressiveness.  If you have a
verb (u) that operates in a certain domain, and your arguments are in a
different domain, define a verb (v) that converts to the domain of (u); then
(u&.:v) will transform domains, apply (u), and transform back.

Duals will pop up everywhere you look once you have trained yourself to think
of them.
)
<.@(0.5&+) 0 0.4 0.6 0.9  NB. Round to nearest integer
NB. Multiply by 100, round to nearest integer, then divide by 100
<.@(0.5&+) &.: (*&100)  0.001 0.009 0.045 NB. Round to nearest hundredth

NB. The magnitude of a vector is the square root of the sum of the squares:
mag =: +/&.:*:  NB. Square, sum, take square root
mag 3 4 5

NB. The geometric mean is the mean in logarithmic space
mean =: +/ % #
geomean =: mean&.:^.
mean 3 4 5
geomean 3 4 5

NB. Delete first letter of each word.  Add leading space, cut to find
NB. words.  Then, on each word, remove leading space, remove first
NB. character, replace leading space.  Run the words together and then
NB. remove the space added initially
delinitial =: ;@:( <@:(}. &. (' '&,^:_1)) ;.1 ) &. (' '&,)
delinitial 'list of words'
NB. Note the nested uses of dual

NB. ============================================================================
Lab Chapter Gerunds, Tie, and Agenda
NB. ============================================================================
Lab Section What is a Gerund?
A GERUND is a noun that contains a description of one or more entities.
The entities can be any part of speech, but the gerund is a noun.

Every entity has a unique ATOMIC REPRESENTATION [AR] which is a
boxed noun [and therefore an atom, since a box is an atom; hence the name].

A gerund is an AR, or a list of them.

There is no special flag indicating that a noun is an AR.
There are contexts in which you are allowed to use a gerund; if you put
a noun there, you will get an error if the noun does not contain valid ARs.

The simplest way to create the AR of a verb is with the
TIE conjunction (`).
  (u`'')
will create the AR of (u).
)
NB. You can create atomic representation and look at them:
+`''    NB. A verb
(+/ % #)`''   NB. A more complex verb

NB. You can operate on an atomic representation just as on any noun:
> (+/ % #)`''  NB. Remove outer boxing

NB. ============================================================================
Lab Section Atomic Representations
Every entity has an atomic representation [AR], even modifiers.

But since a modifier by itself cannot be an operand to a modifier, the
tie conjunction cannot be used to create the AR of a modifier:
(&`'')  for example does not give the AR of (&) - it is a syntax error.

The foreign (5!:1) will produce the AR of any entity with
a name.  You give the name as a boxed noun, as in

5!:1 <'name'

The result is the AR.

The foreign (5!:0) is an adverb which, when applied to an AR,
returns the entity it describes, which may be any part of speech.

The adverb (`:6) does the same thing.
)
avg =: +/ % #
5!:1 <'avg'  NB. See the AR for a verb
each =: &.>
5!:1 <'each'  NB. See the AR for an adverb
ints =: i. 4
5!:1 <'ints'  NB. See the AR for a noun

NB. ============================================================================
Lab Section
You can make atomic representations by hand, as shown below.

The need for doing so seldom arises.
)
NB. y is string name of verb, result is AR of verb
arverb =: <@,
NB. y is noun, result is AR of noun
arnoun =: <@((,'0')&(,&<))
NB. (adverb) m is modifier (in string form), x (optional) is AR, y is AR
NB. Result is AR of x m y (conjunction) or y m (adverb)
armod =: 1 : '<@((,&<~ ,)&m)@,"0'
NB. y is a list of 3 ARs, result is AR of their fork
arfork =: <@((,'3')&(,&:<))
NB. x is AR, y is AR, result is AR for (x y)
arhook =: <@((,'2')&(,&:<))@,"0

avg2 =: arfork ('/' armod arverb '+') , (arverb '%') , (arverb '#')
avg2 5!:0    NB. Convert the AR back into an entity

avg2 `: 6  NB. Another way to convert to an entity

NB. ============================================================================
Lab Section Making gerunds using (`) [Tie]
A gerund is an atomic representation [AR], or a list of ARs.

The way to make a gerund out of a list of verbs is with the (`) conjunction,
as in

+`-`(+/ % #)`*

This creates a gerund which has 4 ARs, one for each verb.

This is all you really have to know to use gerunds.
)
+`-`(+/ % #)`*  NB. The gerund is the AR of the component verbs
#   +`-`(+/ % #)`*  NB. The gerund is a list of 4 boxes, one for each verb

NB. Note that, to be hairsplittingly accurate, the form +`'' is not
NB. the AR of the verb + .  That AR is an atom.  The result of +`'' is a
NB. 1-element list:
add =: +
5!:1 <'add'  NB. The AR of the verb 'add'
$ 5!:1 <'add'  NB. it is an atom
$ +`''   NB. +`'' is a list

NB. ============================================================================
Lab Section
If you think about it, you might find it puzzling that (a`b`c`d)
produces the correct result.  After all, it is executed as
(((a`b)`c)`d)  [because the conjunctions are executed left-to-right]
so why doesn't ((a`b)`c) produce
[the AR of the concatenated ARs of (a) and (b)] and [the AR of (c)]
?

The trick is that (`) does not blindly produce the AR of its operands.
It produces the AR of a VERB operand, but it leaves any NOUN operand
unchanged.  It then concatenates the two.  So, when (`) is applied between
a sequence of verbs, each verb is converted to an AR once and left
unchanged after that.

This explains why our use of (+`'') produces the result it did.  ('') is an
empty list, so (`) converts (+) to AR form and concatenates that box with
the empty list to produce a 1-item list.  The ('') is not converted to AR
form - it just vanishes, an empty list concatenated to a non-empty list.
The concatenation leaves one trace: it is why the result of (+`'') is
a 1-item list rather than an atom.
)
+`-`%`*
NB. Executed as:
((+`-)`%)`*
NB. A noun operand is passed through unchanged:
+`(<'abcd')
NB. You can't concatenate a box to a number, though:
+`1 2 3
NB. You can use ` in place of , to avoid parentheses:
a =: 0 1
b =: 2 3
b`a { 'abcd'  NB. No parens needed, since ` is a conjunction
(b,a) { 'abcd'  NB. Parens required

NB. ============================================================================
Lab Section Using Gerunds: Agenda
The simplest use of a gerund is the form

gerund @. noun

which is a SELECTED VERB [also known as an AGENDA, for reasons unfathomable to me]

The gerund is a list of ARs, and the noun is the number of which one should
be used.  The result of the selected verb is a single verb that can then be
applied to arguments.

(gerund @. noun)  is equivalent to  ((noun { gerund) `: 6)

An AR is selected and then turned into a verb.  The noun must be a single number, but it may use negative indexing.
)
NB. The result of the selection is a verb:
+`-`%`* @. 2
NB. The gerund is any well-formed sequence of ARs:
(+`- , 2 # ^`'') @. 2
NB. The selection follows the usual rules; the selector can be negative,
NB.   in which case the selection count back from the end:
+`-`%`* @. _1
NB. The result of verb selection can be applied like any other verb:
(+`-`%`* @. 2) 1 2 3

NB. ============================================================================
Lab Section Using Gerunds: Computed Agenda
A more useful form of selected verb makes the selection of the verb
depend on the data.  This form is

[x] gerund @. v  y

where (v) is a verb that returns an atom.  The atom is used to select
the gerund that will be converted to a verb and executed.
The arguments of (v) and the arguments of the selected verb are the same:
they are the (y) and [optional] (x) arguments of the (gerund@.v) compound.

(v) must produce an atom.  The rank of (gerund@.v) is the same as the rank of (v), but you can use (") to make a verb-selection
compound that works on cells of any rank.
)
NB. (>&0 - <&0) y produces signum of y: _1, 0, or 1 depending on sign
(>&0 - <&0)  _3 0 3
1:`*:`+: @. (>&0 - <&0)  _3 0 3   NB. 1 if y=0, y^2 if y>0, y*2 if y<0
NB. It failed because signum was applied to the entire y
NB.  and did not produce an atom.

NB. A simpler way to take the signum is with the primitive *
*  _3 0 3
1:`*:`+: @. *   _3 0 3   NB. 1 if y=0, y^2 if y>0, y*2 if y<0
NB. It worked!  Why?  The rank 0 n@.v is the rank of v.  The rank of * is 0,
NB. so the selection was performed on each atom individually, and each
NB. application of * produced an atom.

NB. Note that a different verb was applied to each atom

NB. You can use mnemonics if that helps you remember the operations:
Or =: `
BasedOn =: @.
(1: Or *: Or +:) BasedOn *   _3 0 3

NB. ============================================================================
Lab Section Using Gerunds: Multiple AR Assignment
There is a special form of multiple assignment that interprets the right side
as ARs, converts them to entities, and assigns them to the names in the
left side.

This form is indicated when the first character in the multiple-assignment
target string is (`).  The rest of the string is the names to be assigned,
and the right side is a list of ARs.  More than one name must be assigned.

An example is:

'`plus minus times div' =: +`-`*`%
)
'`plus minus times div' =: +`-`*`%
plus   NB. plus is now a verb
minus  NB. minus too
2 plus 2

NB. ============================================================================
Lab Section Using Gerunds With Partitioning and Interval Modifiers
Many of the adverbs that operate on parts of an array can take gerund
operands in the place of the usual single verb.  The items of the
gerund are converted to verbs, and the verbs are used cyclically: each
time the operand verb is to be applied, one single verb from the gerund
is used, and for the next application of the operand verb, the next verb
from the gerund is applied, and so on, with the verb selection wrapping back
around to the beginning of the gerund if there are more applications of verbs
than there are ARs in the gerund.

The simplest example is

+`-/ 1 2 3

which is executed as follows:

(u/ 1 2 3)   is the same as   (1 u 2 u 3)

and with the gerund, the verbs are substituted cyclically, so

(+`-/ 1 2 3) is the same as   (1 + 2 - 3)

All the partitioning and interval adverbs support gerund forms.
)
+`-/ 1 2 3
1 + 2 - 3   NB. Equivalent form
+`-/ 1 2 3 4
1 + 2 - 3 + 4  NB. Equivalent form

1 (<:`>:`+:)\  0 1 2 3  NB. Decrement, Increment, Double
NB. One verb was applied to the corresponding subsequence, with the first
NB. verb being repeated because there were more subsequences than verbs.
NB. Note that each subsequence, and therefore each result, is a list, so the
NB. overall result has rank 2.

NB. ============================================================================
Lab Chapter Partitions and Intervals
NB. ============================================================================
Lab Section Selective Modifiers
While J's ordinary primitives apply to an entire argument, or to every
cell of an argument, J provides ways for you to break up an argument into
pieces and apply a verb on each piece.  Using these mechanisms, you
get the terseness of having short expressions that operate on many
different parts of the argument, combined with the flexibility of having
control over what the parts look like.

The things that make it happen are the SELECTIVE MODIFIERS: adverbs and
conjunctions that take a verb operand (u) and create a derived verb, a new verb
that applies (u) on parts of its (y) argument.

The verb created by a selective modifier can be invoked as a monad or
as a dyad.  Either case will apply (u) to parts of (y).  In the monadic case,
the parts will be defined by the specification of the selective
modifier, possibly referring to the (y) argument.  In the dyadic case,
the (x) argument will be used to define the parts of (y) that are operated on.

The selective modifiers are the adverbs (\), (\.), and (/.) and the conjunction (;.).
(;.) is a conjunction but its operation varies so much depending on its right
operand that we will consider the right-operand values individually.  The
combination of (;.) and a particular right operand is an adverb.
)

NB. ============================================================================
Lab Section Implicit Regular Subarrays: (u\ y) and (u\. y)
The verbs (u\ y) and (u\. y) apply (u) on regularly defined
subsets of (y).

Each subset is a sequence of sequential items of (y).  For (u\) the subsets are
all the PREFIXES of (y); for (u\.) the subsets are all the SUFFIXES of (y).

A prefix of (y) is a set of sequential items beginning with the first item.
A suffix of (y) is a set of sequential items ending with the last item.

(u\ y) applies (u) once for each possible prefix, in other words (#y) times.
The first prefix contains just the first item, and the last prefix contains
all the items.  The result of the applications of (u) are collected into
an array, with each result of (u) being one item of the array.  The rank
of the overall result therefore has rank one higher than the rank of
the results from (u).

(u\. y) also applies (u) (#y) times.  The first suffix contains all the items of (y),
and the last suffix contains just the last item.

Each prefix/suffix is a list of items of (y), and thus has the same rank as (y) unless (y) is an atom.
)
<\ 1 2 3 4 5   NB. Box each prefix
<\. 1 2 3 4 5  NB. Box each suffix
#\ 1 2 3 4 5   NB. Length of each prefix
#\. 1 2 3 4 5  NB. Length of each suffix
]\ 1 2 3 4 5   NB. Prefixes: note each is a list, so they make a rank-2 array
NB. The prefixes were padded with fill when they were collected into an array.

NB. ============================================================================
Lab Section (u/\ y) and (u/\. y)
(u\ y) and (u\. y) are most often used when u is of the form (u/).

In (u/\ y), (u/) is applied to successive prefixes.  Consider a 4-item (y) argument
y0 y1 y2 y3 .
 The first prefix is y0;         applying (u/) gives y0
 The second prefix is y0 y1;     applying (u/) gives y0 u y1
 The third prefix is y0 y1 y2;   applying (u/) gives y0 u y1 u y2
 The last prefix is y0 y1 y2 y3; applying (u/) gives y0 u y1 u y2 u y3

Verify that by this definition (+/\ y) gives the running sum, and (>./\ y)
gives the largest value encountered before or including each item of (y).

(u/\. y) is a mirror-image of (u/\ y):
 The first suffix is y0 y1 y2 y3; applying (u/) gives y0 u y1 u y2 u y3
 The second suffix is y1 y2 y3;   applying (u/) gives y1 u y2 u y3
 The third suffix is y2 y3;       applying (u/) gives y2 u y3
 The last suffix is y3;           applying (u/) gives y3

For general (u), (u/\. y) is much faster than (u/\ y) because with right-to-left
execution the interpreter can calculate the suffixes in reverse order with just
one application of (u) for each, while each prefix must be calculated from
scratch.
)
+/\ 1 2 3 4 5  NB. Running sum
+/\. 1 2 3 4 5  NB. Reverse running sum
>./\ 3 1 4 1 5 9 2 6  NB. Running maximum
*./\ 1 1 1 0 0 1 0 1 0 NB. Mask of leading 1s

NB. ============================================================================
Lab Section Explicit Regular Subarrays: (x u\ y) and (x u\. y)
The dyads (x u\ y) and (x u\. y) apply (u) on regularly-defined parts of (y), but
the parts depend on the (x) argument.

(x u\ y) applies (u) to INFIXES of (y): blocks of sequential items of (y), not
necessarily starting with the first item or ending with the last.  Which
infixes are used depends on whether (x) is positive or negative.

If (x) is positive, (u) is applied to every possible infix of (y) that has length (x).
The first infix starts with the first item of (y), the second starts with the
second item of (y), and so on.  If (x) is greater than (#y), there are no
infixes of length (x).  The result of the applications of (u) are collected into
an array, with each result of (u) being one item of the array.  The rank
of the overall result therefore has rank one higher than the rank of
the results from (u).

If (x) is negative, (u) is applied to non-overlapping infixes of length (|x), and
if the last such infix ends before the end of (y), (u) is also applied to the
extra remaining bit [the TRAILING SHARD].

(x u\. y) applies (u) to OUTFIXES of (y): copies of (y) from which an infix has
been deleted.  The definition follows the definition of (x u\ y), but each
application of (u) is to an outfix instead of the corresponding infix.
)
2 <\ pi =. 3 1 4 1 5 9 2 6 5 3 5  NB. Box each infix
2 (+/ % #)\ pi   NB. Moving average of each 2-infix
3 (+/ % #)\ pi   NB. Moving average of each 3-infix
# pi     NB. There are fewer infixes than items
# 2 (+/ % #)\ pi
# 3 (+/ % #)\ pi
_5 ]\ 'there is a tide in the affairs of men'  NB. non-overlapping infixes
2 <\. 3 1 4 1 5 9   NB. Box each outfix

NB. ============================================================================
Lab Section Explicit Regular Subarrays: (x u;.3 y) and (x u;._3 y)
(x u;.3 y) and (x u;._3 y) are similar to (x u\ y), but they can operate on
multidimensional blocks of (y).  The (x) argument describes the blocks.

(x) is a rank-2 array, in which the first item (0{x) contains the STARTING
MULTIPLE for each block, and the second item (1{x) contains the SHAPE PREFIX
for each block.  The blocks are positioned at each multiple of the starting
multiple that fits in the array, and the size of each block is given by
the shape prefix.  If the shape prefix is shorter than the rank of the array,
the omitted axes are taken in full.

If an item in the shape prefix is negative, the block is reversed along
that axis before (u) is applied.

The results are assembled in a multidimensional array.

(x u;.3 y) applies u to every block with a starting point in the array,
even incomplete ones at the boundaries of the array.  (x u;._3 y)
applies (u) only to complete blocks.
)
]a =: i. 7 8
(3 3 ,: 2 3) <;.3 a  NB. Spacing 3 3, shape 2 3.  Box the blocks
(3 3 ,: 2 3) <;._3 a NB. Only complete blocks
(3 3 ,: 2 3) (+/ % #)@:, ;._3 a  NB. Average each block (low-pass filter)

NB. ============================================================================
Lab Section Implicit Regular Partitions: (u/. y)
(u/. y) is seldom used.  It applies (u) to the diagonals of (y).

If (y) is a list, the diagonals are each item individually.  The gerund
form (n/. y) can then be used to apply a different verb to each item.
)
</. i. 3 3  NB. Box the diagonals

NB. ============================================================================
Lab Section Implicit Irregular Subarrays: (u;.1 y) and (u;.2 y)
(u;.1 y), (u;._1 y), (u;.2 y), and (u;._2 y) apply (u) on sequences of items of (y).  The boundary
points between sequences are called FRETS.  For (;.1) and (;._1), the frets are
at each item that matches the first item of (y); for (;.2) and (;._2), the
frets are at each item that matches the last item of (y).

For (u;.1) and (u;._1), the blocks that (u) is applied to begin at a fret and
run up to just before the next fret [or to the end of the array, after
the last fret].  The result of the applications of (u) are collected into
an array, with each result of (u) being one item of the array.  The rank
of the overall result therefore has rank one higher than the rank of
the results from (u).

In (u;.1), the fret is included in the block.  In (u;._1), the fret is not
included in the block, and a block will be empty if there are two frets in
a row.

(u;.2) and (u;._2) are similar, but the blocks end at the frets rather than
beginning at the frets.  In (u;._2) the frets are not included in the blocks.
)
<;.1 ' each word begins with space'  NB. 1st char, space, is the fret item
<;._1 ' each word begins with space'  NB. This time, leave out the fret
<;.2 ' each word ends with space '  NB. Note leading space made a short block
<;._2 ' each word ends with space '  NB. Shorter still with frets removed
]a =. _2 ]\ 0 0 1 2 3 4 0 0 6 7 0 0 7 8 9 10
<;.1 a  NB. Argument can have any rank; here the fret is  0 0
+/;.1 a  NB.  Add up the items in each block

NB. ============================================================================
Lab Section Explicit Irregular Subarrays: (x u;.1 y) and (x ;.2 y)
In the dyadic forms (x u;.1 y) etc., the boolean list (x) indicates the positions
of the frets, rather than having their positions indicated by which items
match the first or last item of (y).

(u) is applied to blocks of (y) as determined by the frets in (x), just as for
the monadic case of (u;.1) etc.

Parts of (y) before the first fret [for (u;.1) and (u;._1)] or after the last fret
[for (u;.2) and (u;._2)] are discarded.  [This situation is impossible in the
monadic uses of (u;.1) etc.]

(x) may be a boxed list, which produces a multidimensional partition
in which the successive boxes of (x) give the frets for successive axes
of (y), and the results of the individual applications of (u) are assembled
into a multidimensional array.
)
0 0 1 0 1 0 <;.1 'abcdef'  NB. Note leading part of y discarded
]a =. 5 5 $ 'abcdefghijklmnopqrstuvwxy'
(0 1 0 1 0;1 1 1 0 0) <;.1 a  NB. Multidimensional cut

NB. ============================================================================
Lab Section Explicit Irregular Partitions: (x u/. y)
In (x u/. y), the number of items of (x) and (y) must be the same.  The items
of (x) are KEYS for the items of (y), and (u) is applied to collections of items
of (y) that have identical keys.  The items in a single collection need not be contiguous in (y); they are collected into an array, preserving their original order, for (u) to operate on.

The result of the applications of (u) are collected into an array, with each
result of (u) being one item of the array.  The rank of the overall result
therefore has rank one higher than the rank of the results from (u).

(~. x) gives the list of the unique values in (x), in the order of their
first appearance in (x).  The items of the result of (x u/. y) are in the
same order as the items of (~.x); that is, they are the result of applying
(u) to collections of y that have the corresponding value of (~.x) as key.
)
1 2 1 1 2 2 </. 'prayed'  NB. Keys are 1 and 2
~. 1 2 1 1 2 2
'deddee' </. 'prayed'  NB. Keys can be any shape or type
(~. 'deddee') ;"_1  'deddee' </. 'prayed'  NB. Match keys to collections

NB. ============================================================================
Lab Section Explicit Single Subarray: (x u;.0 y)
(x u;.0 y) applies (u) to a single subarray of (y) defined by (x).  The (x)
argument is similar to the (x) argument of (u;.3).  (x) is a rank-2 array,
in which the first item (0{x) contains the STARTING POINT for the block, and
the second item (1{x) contains the shape of the block. If the shape is shorter
than the rank of the array, the omitted axes are taken in full.

If an item of the starting point is negative, the starting point is relative
to the end of the array [as usual for negative indexing], and the subarray
continues to extend backwards from there.  If an item of the shape is
negative, the corresponding axis is reversed before (u) is applied.
)
]a =. i. 8 8
(2 3 ,: 3 2) ];.0 a  NB. starting point 2 3, shape 3 2
(2 _3 ,: 3 2) ];.0 a  NB. starting point 2 _3, shape 3 2 (backwards in axis 1)
(2 3 ,: _3 2) ];.0 a  NB. starting point 2 3, shape 3 2 (reversed in axis 0)
(3 ,: 4) ];.0 'abcdefghij'  NB. Works for lists too

NB. ============================================================================
Lab Chapter Remarks On Selected Verbs
NB. ============================================================================
Lab Section Match (x -: y) Does Not Mean Identical
(x -: y) produces 1 if (x) and (y) MATCH, that is, if they are the same in shape
and values.

(x -: y) is what you use to see if two nouns are the same.  Dyad (=) has
rank 0, so (x = y) gives a result for each atom (and fails with length error
if (x) and (y) do not agree).  (x -: y) gives a single result.

Do not think that two values that match are necessarily identical:

1.  The comparison in (x -: y) is tolerant.  If you want intolerant comparison
on numerics, use (x -:!.0 y).

2.  Empty arguments of the same shape match even if they have different
types.  The consequences of this fact are explored below.
)
1 1 -:       1.000000000000001 1    NB. Tolerant comparison
1 1 -:!.0 ]  1.000000000000001 1  NB. Intolerant comparison

l =: 0$' '  NB. empty character array
n =: 0$2    NB. empty numeric array
b =: 0$a:   NB. empty boxed array
3!:0 l    NB. The type of the empty is preserved
3!:0 n
3!:0 b
l -: n   NB. The arguments are considered to MATCH
l -: b
b -: n
2 {. l   NB. ...but their differences are latent
2 {. n
2 {. b

NB. ============================================================================
Lab Section (x {. y) (x }. y) (x |. y) (x u;.1 2 _1 _2 y) can be multidimensional
The dyads that work on arrays:

(x {. y) (x }. y) (x |. y) (x u;.1 y) (x u;._1 y) (x u;.2 y) (x u;._2 y) 

allow the operation to be performed on multiple axes.  This is a
feature that is often overlooked.

For ({.), (}.), and (|.), (x) can be a list whose items give the values for successive axes.

For (u;.), (x) can be a boxed list whose opened contents give the frets for
successive axes.
)
]a =: 3 6$'abcdefghijklmnopqrstuvwx'
1 |. a  NB. Rotate a left 1 on axis 0
1 _2 |. a  NB. Rotate a left 1 on axis 0, right 2 on axis 1

2 {. a  NB. Take first 2 items
2 _2 {. a  NB. Take first 3 items of axis 0, last 2 of axis 1

1 0 1  <;.1 a  NB. Box the sequences delimited by frets
(1 0 1  ; 1 0 0 0 1 0) <;.1 a  NB. same, multidimensional

(1 0 1 ; 1 0 0 0 1 0) <@$;.1 a  NB. just box the shapes of the subarrays

NB. ============================================================================
Lab Section Use (i.~ y) to Self-Classify
(i.~ y)  which is equivalent to

y i. y

is a phrase you might not think would be useful, but it comes up
surprisingly often.  The result is a list whose length is the number
of items of (y); for each item, the result gives the index at which
that item first appears in (y).

Duplicate items of (y) all have the same identical result value, so the
result of (i.~ y) is to SELF-CLASSIFY (y), giving each unique value among
the items of (y) a number, and then representing each item by its
corresponding number.
)
]a =: ;: 'a rose is a rose is a rose according to Gertrude Stein'
i.~ a  NB. self-classify: an equivalence-class number for each item of a
(i.~ a) { a   NB. see how this restores a
NB. /:@/: gives the ordinal for each number in (a):
NB. position of each atom of a in the sorted list /:~ a
/:~ a   NB. a sorted into order
/:@/: a    NB. The ordinals of a
(i.~ a) { /:@/: a  NB. For each a, the ordinal of the first atom with that value
NB. Now: for each item of a, the number of earlier identical items
(i.~   (] - {)   /:@/:) a

NB. ============================================================================
Lab Section (x %. y) for Rough-And-Ready Regression
We will use the abbreviation (mp) for matrix product, defined as
 mp =: +/ . *

For a square matrix (y),   (%. y) is the matrix inverse of (y).

If y is not square, it must have more rows than columns, and
     (%. y)  is   ((%. (|:y) mp y) mp (|: y))
 in math notation, (%. y) is   (YtY)'Yt    where '=inverse, t=transpose


(x %. y) is matrix division, which is defined as ((%. y) mp x).

If (x) is a vector of observations and (y) is a matrix of explanatory variables,
(x %. y) gives the regression coefficients.

(y mp x %. y) gives the projection of (x) onto the column space of (y).


(%.) fails when the columns are dependent.  Regression using (%.) gives
poor results when the columns are almost dependent - use SVD,
part of the LAPACK addon, in that case.

(%.) applied to a list treats the list as a column vector, that is, it applies
(,.) to the list to turn it into an array.
)
mp =: +/ . *
NB. Do some timing on the J sort verb: take stats, perform regression
NB. Setup: verb to time a sentence
etime =: 10&(6!:2)
NB. Vectors of random numbers
irand =: ? 100000 $ 100000
frand =: ? 100000 $ 0
NB. Test 1: integer sort.  cmds is the command string to use, v is vector length
]cmds =: '/:~ irand {.~ '&,&.> <@":"0 v =: 1 10 100 1000 2000 5000 10000 20000 100000
NB. Run em and capture times
t =: > etime&.> cmds
NB. Regression against 4 variables: constant, n, nlogn, and n^2
t %. (1 ,. ] ,. (* ^.) ,. *:) v

NB. Repeat using floating-point numbers
cmds =: '/:~ frand {.~ '&,&.> <@":"0 v =: 1 10 100 1000 2000 5000 10000 20000 100000
t =: > etime&.> cmds
t %. (1 ,. ] ,. (* ^.) ,. *:) v

NB. Repeat, restricting numbers to range 0-1000 (meaning lots of repeats)
irand =: ? 100000 $ 1000
cmds =: '/:~ irand {.~ '&,&.> <@":"0 v =: 1 10 100 1000 2000 5000 10000 20000 100000
t =: > etime&.> cmds
t %. (1 ,. ] ,. (* ^.) ,. *:) v

NB. ============================================================================
Lab Section Use (x +/ . * y) for Matrix Multiplication
(x +/ . * y) is the matrix product of (x) and (y).

You can think of other ways to write this, like (+/@(*"1 _)).

Don't.  (+/ . *) is heavily optimized in the interpreter.  It is OK to assign (+/ . *) to a name, such as (mp).
)

NB. ============================================================================
Lab Section Observations on (x #. y) and (x #: y)
In  (x #. y), (x) gives the place values of the digits of (y), and the result
is the total value.

The weight for each digit is the product of its place value and all
the place values of succeeding digits: in other words,
 (*/\.}.x,1).

Note that the leading item of (x) disappears from this list of weights.
It can be anything.  An atomic (x) is allowed and it is replicated as much as
necessary.


The reverse of this,  (x #: y), uses the same place-value list, but
it converts the single number (y) into one digit for each item of (x).

In this case, the leading item of (x) is significant.  If the leading
item of the result is not at least 0 and less than ({. x), the correct integer multiple of
({. x) is added to bring it into that range.

If you want to avoid this modification of the leading item of the result,
make the leading item of (x) 0 or (_).


When you use (x #: y) your (x) must have as many items as you want places in the
result.  If (x) is an atom, you get an atom result.

If you want an atom (x) to be repeated for (x #: y) in the same way it was for
(x #. y), use (x #.^:_1 y).
)
10 10 10 #. 9 7 1   NB. Convert place values to a single number
*/\.}.10 10 10 ,1   NB. The list of weights for each place
0 10 10  #. 9 7 1   NB. Leading item of x doesn't matter
10 #. 9 7 1  NB. Atomic x is replicated as needed


10 10 10 #: 971   NB. #: works the other direction
10 10 10 #: 2345  NB. Leading digit is forced into range
0 10 10  #: 2345  NB. That can be prevented...
_ 10 10  #: 2345  NB. ...if leading item is 0 or _

10 #: 2345  NB. An atom is not replicated for #:
10 #.^:_1 (2345)  NB. But #.^:_1 will do that

NB. ============================================================================
Lab Section Recursion with ($:)
The ($:) verb performs recursion.  ($:) stands for the verb phrase it is
a part of, and so indicates the point or recursion.

($:), like any verb, can be part of many verb phrases at once: in

a@b@c@d

(a) is part of itself, (a@b), (a@b@c), and (a@b@c@d).  So which phrase is the
one that is invoked by ($:) ?

The longest one.  That means the biggest piece of the verb that you
could put parentheses around, enclosing the ($:), and keep the meaning of
the sentence unchanged.

You can also do recursion by name, simply by having a verb invoke itself
either directly or indirectly.
)
factorial =: (* $:@<:) ^: (1&<)  NB. Factorial function
NB.         (                  )  This is the part that $: refers to
factorial 4
factorial 4 5  NB. It might be interesting to see why this happened.  We won't.
     (* $:@<:) ^: (1&<) 4
NB. (                  )  What $: refers to
     1 + (* $:@<:) ^: (1&<) 4
NB.     (                  )  What $: refers to.  More would change the meaning
     (1 + (* $:@<:) ^: (1&<)) 4
NB. (                        )   Now $: refers to the larger phrase

explicitfac =: (* explicitfac@<:) ^: (1&<)
1 + explicitfac 4
(1 + explicitfac) 4  NB. The referent for explicitfac doesn't change

NB. ============================================================================
Lab Section Use (x # y) to Repeat Items
(x # y) is used with Boolean (x) to select the items of (y) for which (x) is 1.

This is a special case of (x).  Generally, an atom of (x) tells how many
copies of the item of (y) to take.  This can be 0 or 1 (the Boolean case), or
any other positive integer, which will cause items of (y) to be repeated in
the result.

Moreover, an item of (x) can be complex, in which case the imaginary part
tells how many fills to insert after the copies of the item of y; and
the fill atom to be used for all fills can be given by the Fit conjunction
(!.f).
)
1 0 1 0 # 'abcd'
1 0 2 0 # 'abcd'  NB. repeated item
1 0j1 2j1 0 # 'abcd'   NB. 1 fill after a couple of the copies
1 0j1 2j1 0 #!.'*' 'abcd'  NB. Use asterisk for the fill

NB. ============================================================================
Lab Section Circle Functions (x o. y)
(x o. y) applies special function number (x) to (y).  The special functions
are described in NuVoc and are worth a look.  They include all
the trig functions, plus hyperbolic functions, and also some other functions
including a few related to complex numbers.

You can remember the first few functions by noting that the sine function
is odd, so its number is odd: (1&o.) is sine, (2&o.) is cosine.

((-x)&o.) is generally the inverse to (x&o.), so (_1 o. y) gives the Arcsine of (y).
)

NB. ============================================================================
Lab Chapter Selected Foreigns
NB. ============================================================================
Lab Section The Foreign Conjunction (!:)
FOREIGNS are entities created by the FOREIGN CONJUNCTION (!:) that do things
outside the language as described by the primitives.  The obvious sorts
of things that are foreign are I/O and interfaces to operating systems
and other software packages.  Other foreigns do things like locale
management, reading and setting interpreter control information,
converting data from one format to another, etc.

All foreigns have the form  (m!:n) where (m) and (n) are numbers.  In effect,
the foreigns are just dozens of numbered entities that have special
functions.  You may want to give the ones you use mnemonic names.

The value of (m) separates the foreigns into classes, in which the
foreigns (m!:n) are loosely related.

Sections of this chapter will give a very small sampling of the available
foreigns.

The entity produced by (m!:n) is almost always a verb, and that is to be assumed unless otherwise noted.
)

NB. ============================================================================
Lab Section Files (1!:n)
A file is designated by a boxed filename or a file number which is returned
by (1!:21 y).  A filename that is not fully qualified is taken as relative
to the current Working Directory.


(1!:1 file)  reads file, result is the text of the file

(x 1!:2 file)  writes (and replaces) (file), text is (x)

(x 1!:3 file)  appends (x) to (file)

(1!:0 y) fetches directory information.  (y) is a string, not a filename, and
may contain ? and * characters.

(1!:11 file ,< index,length)  NB. read (file), starting at (index)

(x 1!:12 file ,< index) NB. Write (file), starting at (index) (length is (#x))

(1!:21 file)  open (file), returning file number
(1!:22 filenumber) close file

(1!:43 '') result is current Working Directory
(1!:44 y) set Working Directory

(1!:55 file) erase (file)
)
1!:43 ''  NB. current Working Directory
1!:0 '*.exe'  NB. executables in the current Working Directory
1!:1 <'version_bin.txt'  NB. Read a file

NB. ============================================================================
Lab Section Types and Conversions (3!:n)
(3!:0 y)  type of (y): 1=Boolean, 2=character, 4=integer, 8=float, 16=complex,
32=boxed, ... [there are more]

(x 3!:4 y) x>0: convert J integers to character string [type cast]
x<0: convert character string to J integers [type cast]
(x 3!:5 y)  similar, to type-cast J floats

(x 3!:4 y) and (x 3!:5 y) are used to convert data to a byte string for
passing to an external program
)
3!:0 (0)  NB. Boolean
3!:0 i. 3  NB. Integer
3!:0 (0.5) NB. Float

2 (3!:4) 1 2 3  NB. A bunch of nondisplayable characters
a. i. 2 (3!:4) 1 2 3  NB. This shows the characters as numbers

NB. ============================================================================
Lab Section Names  (4!:n)
(4!:0 <'name') Class of (name): _2=invalid _1=unused 0-3=noun, adverb, conj, verb

(4!:1 class-list) List of names in (class), which is a list of the desired parts of speech:
0-3=noun, adverb, conj, verb  6=locale
)
a =: i. 2 3  NB. A Noun
plus =: +
4!:0 <'a'
4!:0 <'plus'
4!:1 (0 1 2 3)

NB. ============================================================================
Lab Section Representation (5!:n)
(5!:5 <'name') Produces a string which, when interpreted, yields the named
entity
)
]a =: ('abc';'de';'fgh');0 2.25 4.5 6.75 9 11.25 13.5 15.75
5!:5 <'a'   NB. Clever, eh?

NB. ============================================================================
Lab Section Time  (6!:n)
(6!:0 '') current local time  y m d h m s
(6!:1 '') seconds since start of session.  A single number.
([x] 6!:2 sentence)  execute (sentence) (x) times [default=1], report average time
(6!:3 y)  delay y seconds
)
6!:0 ''
6!:1 ''
6!:3 (5)

NB. ============================================================================
Lab Section Space  (7!:n)
(7!:2 sentence)  execute (sentence), report space used
)
7!:2 'i. 1000000'   NB. Create 1000000 4-byte entries
a =: i. 1000000
7!:2 'a'   NB. producing the array as a result doesn't require copying it
7!:2 ']a'   NB. Nor does the ] verb
7!:2 '+a'  NB. But + [conjugate] does, even for a real array

NB. ============================================================================
Lab Section Locales  (18!:n)
A J LOCALE is a public namespace.  It has nothing to do with timezones.  The locale is at the heart of object-oriented J.

(18!:2 y)  return search path for locale y
(x 18!:2 y) set search path for locale y to x
(18!:5 '') return current locale
)
18!:5 ''  NB. the current locale
18!:2 (18!:5 '')  NB. The path of the current locale

NB. ============================================================================
Lab Chapter Empty Arguments
NB. ============================================================================
Lab Section Empty Arguments - A Natural Extension
One of the great things about J is that you don't have to count out your
loops carefully.  You apply a verb to an array of cells, and it works
on each cell exactly once.

This is nowhere more important than in the case where there are no cells.
When there are no argument cells, there will be no result cells; but
it is still important for the empty result to have the correct shape.

We must be careful to distinguish between an EMPTY ARGUMENT, which has
no cells, and an ARGUMENT WITH EMPTY CELLS, which has cells that are
themselves empty.

Recall some basic terminology.  The RANK (r) of a verb is the largest
rank the verb can operate on internally; its argument is viewed as
an array of (r)-CELLs [that is, cells of rank (r)], and the verb is applied
to each (r)-cell independently.  The shape of the array of (r)-cells,
in other words that part of the shape of the argument after the trailing
(r) axes are removed, is called the (r)-FRAME of the argument.  The results
of applying the verb on the (r)-cells are assembled into an array whose
shape has the (r)frame of the argument as a prefix.
)
]a =: i. 2 3 4  NB. Our test argument for the following example

NB. ============================================================================
Lab Section
)
NB. We will illustrate the frame by using a verb that boxes its argument.
NB. Since each box is an atom, the shape of the result will just be the
NB. frame of the original argument.

<"2 a  NB. (<"2 a) is an array of 2 2-cells
$ <"2 a  NB. The shape of that array is the 2-frame of a
$ L:0 <"2 a  NB. The shape of each result cell

<"1 a  NB. (<"1 a)  is a 2x3 array of 1-cells
$ <"1 a  NB. The shape of that array is the 1-frame of a
$ L:0 <"1 a  NB. The shape of each result cell

< a  NB. Rank of < is _; this is a 0-dimensional array of _-cells
$ < a  NB. The shape of that array is the 1-frame of a
NB.  _-frame of anything is always empty
$ L:0 < a  NB. The shape of each result cell

NB. ============================================================================
Lab Section Definition of an Empty Argument
An EMPTY ARGUMENT is one that has a zero in its frame.  This means that the
argument has a zero in its shape, but that zero is not one of the last (r)
items of the shape [(r) is the rank of the verb].  An empty argument must always have a rank higher than the rank of the verb.

An ARGUMENT WITH EMPTY CELLS has a zero in one of the last (r) atoms of its shape.
Then, each (r)-cell has a zero in its shape, i. e. is empty.

It is possible for an argument both to be empty and to have empty cells, if
it has more than one zero in its shape.
)
] a =: i. 2 0 3 4  NB. Our test argument.  No cells.
<"1 a  NB. Box the 1-cells.  Argument is a 2 0 3 array of 1-cells.
$ <"1 a   NB. The 1-frame of the argument.  This is an EMPTY OPERAND

<"2 a  NB. Box the 2-cells.  Argument is a 2 0 array of 2-cells.
$ <"2 a   NB. The 2-frame of the argument.  This is an EMPTY OPERAND

<"3 a  NB. Box the 3-cells.  Argument is a 2 array of 3-cells.
$ <"3 a   NB. The 3-frame of the argument.  This is an OPERAND WITH EMPTY CELLS.
$ L:0 <"3 a   NB. The shape of each argument cell is 0 3 4

NB. ============================================================================
Lab Section Empty Arguments Produce Empty Results
Applying a verb to an empty argument produces an empty result.  This
is not a special rule; it follows directly from the standard rules
from processing verbs.

The results from applying the verb to the individual cells are assembled
into an array whose shape is the frame of the argument.  Since an empty
argument by definition has a zero in its frame, the result of applying
the verb to that argument will have that zero in the result shape, in other
words it will be an empty result.

But what shape will that empty result have?  Knowing that the result
is empty doesn't tell you its shape, it only tells you that the shape
contains a zero.

For non-empty arguments, each application of the verb to a cell gives
a result cell with a definite shape, and the shape of the overall result is
an array of cells with that shape [padding the result cells with fills if
their shapes are not identical].  But with an empty argument, there are
no cells to apply the verb to, so what shape should the result cell have?
)

NB. ============================================================================
Lab Section The Fill Cell
When a verb is applied to an empty argument, the interpreter creates a cell,
called the FILL CELL, which has the shape of one cell of the argument.
The value of each atom in the fill cell is a fill of the appropriate
type: (0) if the argument is numeric, (' ') if the argument is character,
(a:) if the argument is boxed.

If the verb has two arguments [i. e. it is invoked as a dyad], the calculation of the fill cell is performed independently on eachg argument.

The verb is applied to the fill cell[s], and the shape and type of the result
are noted.  The frame is appended to the shape of the
fill-cell result to give the overall result of the verb.

The beauty of this system is that the empty-argument result fits into the
sequence of result shapes.  2 cells, 1 cell, 0 cells: they form a regular
pattern.
)
v =: monad : '((# y) $ 0 1) # y'"1   NB. Take every other item of list y
v 0 1 2 3 4 5 6
v i. 2 6  NB. Result from 2 cells
v i. 1 6  NB. Result from 1 cell
v i. 0 6  NB. Result from 0 cells.  Fill cell is 6 $ 0
$ v i. 0 6  NB. Note that the shape is correct: 0 items, but each has shape 3
(v i. 0 6) , (v i. 2 6)  NB. Results can be joined properly...
(0 6 $ 0) , (v i. 2 6)  NB. ...which would not be true if shape of result on empty were wrong

NB. ============================================================================
Lab Section When Executing on the Fill Cell Results In Error
If the execution of the verb on the fill cell results in an error,
the interpreter carries on as if the execution had returned a numeric
atom.  An atom has empty shape.  Remember, this empty result from the fill will be concatenated to the frame of the argument to produce the shape of the result.  The frame will contain a 0 so the result will always be empty.

If this is not what you want, you have to program more carefully.


)
5 + ' '   NB. You can't add a character to a number
5 + ''  NB. Why doesn't this fail?  '' is still a character.
NB. The verb was executed with a cell of fills, as 5 + ' '.  That failed,
NB. and execution continued as if it had returned 0...
$ 5 + ''  NB. ...so overall result shape is (,0)

NB. ============================================================================
Lab Section Arguments With Empty Cells
An argument with empty cells is processed by the verb just like any
other argument.  No fill cell is created: the verb is applied to the empty
cell and what happens is up to the verb.

The verb may choose to ignore the type of an empty argument.  Most J
primitives ignore the type of empty 'control' arguments, treating them all
as numeric, but preserve the type of 'data' arguments.  For most
primitives the 'control' argument is the (x) argument and the 'data' is (y).
)
2 |. i. 6  NB. |. rotates y left by the amount x
|. b. 0  NB. Left rank 1, right rank _
' ' |. i. 6  NB. character shift amount is not allowed...
'' |. i. 6  NB. but tolerated when empty (treated as numeric)

'' -: 0$0   NB. -: has infinite rank, and treats all empty arguments as numeric

{. b. 0  NB. Left rank 1, right rank _
' ' {. i. 8  NB. character x not allowed...
'' {. i. 8  NB. ... but tolerated when empty
3 {. ''   NB. y argument is 'data', type is preserved
3 {. 0$a:  NB. empty boxed list
3 {. 0$0  NB. empty numeric list

NB. ============================================================================
Lab Section Handling Empty Arguments Yourself
Sometimes executing your verb on a cell of fills will not give you the
correct result.  In those cases, you might need to write code for the
empty-argument case.

By far the most common kind of an empty argument is one that has no
items, in other words when the zero in the frame is the first item in
the shape of the argument.  This is easy to test for using (# y), and you
can write code like

if. # argument do.
...here the argument is known to have items...
end.

More compact ways are shown in the examples.
)
NB. Create a conjunction that applies the verb u if there are items, otherwise
NB. assign the value v
Butifnull =: 2 : 'v"_`u@.(*@#@])'
(>"0) Butifnull ($0)  1 ; 2 ; 3  NB. on nonnull, this just executes (>"0)
$ (>"0) Butifnull ($0)  1 ; 2 ; 3  NB. giving shape 3
$ (>"0) 0$a:   NB.  ...on empty list, shape is 0 0 (because a: contains a list)
$ (>"0) Butifnull ($0) 0$a:   NB. ...so in that case, the default is used

NB. Create an adverb that applies the verb u only if there are items
NB. (otherwise the result is the y argument)
Ifany =: ^:(*@#@])
*/ ''  NB. Result is identity element, which is usually desired
*/ Ifany ''  NB. Result now is unchanged argument, i. e. empty list
$ */ Ifany ''

NB. ============================================================================
Lab Section Interpreter/Language Anomalies
In a few cases the behavior does not correspond exactly to the
rules laid out here.

By redefining primitives as named verbs you can find the cases where
the interpreter or language produces unexpected results.
)
NB. One such case was hidden in the previous example:
$ (>"0) 0$a:
NB. Fill cell is a:, which is <0$0; opening that gives 0$0, so an array
NB. of 0 of them has shape 0 0

NB. But wait a minute: > has rank 0, so isn't > the same as >"0 ?
$ > 0$a:  NB. It should be, but it isn't.

$  5 +"1"1 (0 1 $ ' ')
NB. Correct: the fill cell is 1 $ ' '; 5 + 1 $ ' ' is an error, so the
NB. result on the fill cell is taken as 0; an array of 0 of them has shape 0
$  5 +"1 (0 1 $ ' ')  NB. Should be the same, but it isn't
NB. +"1 is handled by special code (integrated rank support)

NB. Anomalies like this are listed in the bug list on the Wiki.

NB. ============================================================================
Lab Chapter Selecting From and Modifying an Array
NB. ============================================================================
Lab Section Selection (x { y)
Early in your J education you learned that (x { y) selects item (x) of (y).
Now we are going to discuss (x { y) in full generality.

To review: (x { y) gives item (x) of (y).  The left rank of (x { y) is 0,
so if (x) is a list, each atom of (x) produces an item of the result.
If (x) is an array, thse items are assembled into an array.

If (x) is an atom, (x { y) is a single item of (y), having the rank of
an item of (y), which [except for atomic (y)] is one less than the rank of (y).

If (x) is a list, the result is a list of items of (y), which has the
same rank as (y) [again, except for atomic (y)].
)
NB. Our examples will use the alphabet array
] a =: 2 2 4 $ 'abcdefghijklmnopqrstuvwx'

NB. A single item of a has shape 2 4
1 { a
$ 1 { a

NB. A list of the items of a has rank 3, even if there is only 1 item.
NB. This is not special, it's just the normal rules of rank with a verb that
NB. has left rank 0
1 0 { a  NB. Items of result preserve the order of x
$ 1 0 { a
0 1 0 { a
$ 0 1 0 {a
(,1) { a   NB.
$ (,1) { a

NB. ============================================================================
Lab Section Selector in Full Generality
In (x { y), (x) in full generality specifies the selections to be made
along each axis of (y).  The set of indexes to be selected along an axis
is called the SELECTOR for that axis.  It can be an atom or a list.

Since, in general, the selectors for the different axes can have different
numbers of items [the number of indexes chosen for the axes are independent
of each other], the selectors must be boxed in the general case.  The
selectors then form a list of boxes, with box 0 having the selectors for axis
0, box 1 having the selectors for axis 1, and so on.

Because the left rank of (x { y) is 0, the boxed list of selectors must be
boxed again to make an atom that contains all the selection information.

So, in general: (x) is an box [and thus an atom], whose contents are a boxed list, one
box per axis, and the contents of subbox (i) are the selectors for axis (i).
)
NB. A selector to take the first two indexes of each axis, producing a
NB. 2x2x2 array:
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
] sel =: < 0 1 ; 0 1 ; 0 1
sel { a  NB. The selected part of a

NB. ============================================================================
Lab Section
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
NB. The order of the indexes is important, and preserved for each selector:
(< 1 0 ; 0 1 ; 0 1)
(< 1 0 ; 0 1 ; 0 1) { a  NB. first axis reversed
(< 0 1 ; 1 0 ; 0 1) { a  NB. second axis reversed
(< 0 1 ; 0 1 ; 1 0) { a  NB. third axis reversed

NB. The number of indexes can be different for different selectors:
(< 0 1 ; 1 2 ; 0 2 3) { a
$ (< 0 1 ; 1 2 ; 0 2 3) { a

(< 0 1 ; 2 0 1 ; 3 1) { a
$ (< 0 1 ; 2 0 1 ; 3 1) { a

NB. ============================================================================
Lab Section Atomic Selectors Reduce the Rank of the Result
You may have noticed that the shape of the result of (x { y) is given
by the lengths of the selectors in (x).  If box (i) is a list of shape 2,
for example, the result will have dimension of 2 along axis (i).

[Actually the selector can be any array, and its shape will go into the shape of the result, but this is vanishingly rare]
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: <0 1 ; 2 1 0 ; 3 1
; $ L:0 > sel   NB. The shapes of each selector
$ sel { a  NB. match the shape of the selection
sel { a

]sel =: < 1 0 1 ; 2 0 ; 3 2 1
; $ L:0 > sel   NB. The shapes of each selector
$ sel { a  NB. match the shape of the selection
sel { a

NB. ============================================================================
Lab Section
This rule, that the shape of a selector gives the dimension of the
corresponding axis, also applies if the selector is an atom.

But think about what this means: the shape of an atom is an empty list.

That means that the corresponding axis disappears from the shape of the result.

When a selector is an atom, it is saying that the result is not an array
along that axis.  The result is a single slice along that axis, so that
further selection along that axis is impossible.  It is an ex-axis.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1 2 ; 0 1 2  NB. The selector
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. First axis has disappeared

sel =: < 0 1 ; 1 ; 0 1 2
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. Second axis has disappeared

sel =: < 1 ; 1 ; 3 1 0
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. First two axes have disappeared

sel =: < 1 ; 1 ; 3
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. All axes have disappeared

NB. ============================================================================
Lab Section
Note that there is a difference between selector that is an atom,
an empty list, and a list of length 1.

An atom has shape 0$0 (empty) and the axis disappears.

An empty list has shape ,0 and the result is an axis with 0 dimension [which makes the result empty].

A list of length 1 has shape ,1 and the result is an axis with dimension 1.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1 2 ; 0 1 2
sel { a  NB. Selector 0 is an atom, axis disappears
$ sel { a  NB. Axis is gone from shape

]sel =: < (,0) ; 1 2 ; 0 1 2
sel { a  NB. Selector 0 is a 1-item list [you can't tell that from the session
NB. display, but dissect will reveal the leading axis]
$ sel { a  NB. ...but it's there in the shape

]sel =: < (0$0) ; 1 2 ; 0 1 2
sel { a  NB. Selector 0 is a 0-item list, selects no items
$ sel { a  NB. ...as indicated by 0 in the shape

NB. ============================================================================
Lab Section Complementary Selection
If a selector [which is the contents of a box which is part of the
contents of the box (x)] is itself boxed - it is triple-boxed - the
selection is the entire axis EXCEPT the indexes given in the
selector.  Such a selector is called a COMPLEMENTARY SELECTOR.

The axis corresponding to a complementary selector always remains in the
result, even if there is only 1 index selected.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1 2 ;< (<1)  NB. Just one item from axis 0; 0 2 3 from axis 2
NB. NOTE that we had to write ;< for the last axis to get the third level
NB. of boxing.  This is because of the way ; works
sel { a

]sel =: < 1 0 ; (<2) ; 1  NB. like 0 1 ; 0 1 ; 1
sel { a

NB. ============================================================================
Lab Section Simplification: Omitted Trailing Selectors
We have now covered (x) in full generality.  What remains is to understand
the simple [and more common] special cases.

The first simplification is when there are fewer selectors than axes.
In this case, the selectors that are given refer to the leading axes,
and the leftover axes are taken in full.

In the extreme case, where there are no selectors, all the axes are
left over and the entire array is taken in full.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1  NB. Axis 2 taken in full, result is a list
sel { a

]sel =: < <1  NB. Axes 1 and 2 taken in full
sel { a

]sel =: < 0$a:  NB. All axes taken in full
sel { a

NB. ============================================================================
Lab Section Simplification: Omitted Non-Trailing Selectors
There is no way to omit a selector except at the end of the axes, but it
is possible to take an axis in full without giving all the indexes.

If you use complementary selection, and select everything EXCEPT nothing,
you will be selecting the axis in full.  The selector to do this is an
empty list [no indexes], boxed [to call for complementary selection].
This is (< 0$0) or equivalently (<'') or (<$0) or, most simply,  (a:) [which
is defined as (<0$0)].  Think of (a:) as meaning 'all' here.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < a: ; 1 ; 1  NB. Axis 0 taken in full, result is a list
sel { a

]sel =: < 0 ; a: ; 2 0 1  NB. Axis 1 taken in full, result is an array
sel { a

NB. ============================================================================
Lab Section Simplification: Unboxed Atomic Selectors
If all the selectors are atoms, the boxing can be omitted.
(x) will be a boxed list, one atom per axis.  All the axes given in (x)
will disappear from the result.

As usual, omitted trailing axes are taken in full.  From this it can be
deduced that the shape of the result is

(#>x) }. $y
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 0  NB. Axes 0 and 1 given, axis 2 taken in full, result a list
sel { a

]sel =: < 0 0 2  NB. All axes given, result is an atom
sel { a

NB. ============================================================================
Lab Section Simplification: A Single Unboxed atom Selector
If there is only one selector, and it is an atom, the boxing of (x) can
be omitted.  This is the form in which you met (x { y).

Remember that (x { y) has left rank 0, so when (x) is a list, it is really
calculating the result for each atom of (x) independently, and assembling those
results into an array.

The interpreter recognizes the case
 list { y
and treats it the same as
 (<<list) { y
 so there is no reason to prefer the boxed form.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: 1  NB. Select item 1 of axis 0, take others in full
sel { a

NB. ============================================================================
Lab Section Modifying an Array: (x m} y)
To modify an array you need the array, the values to put into it, and
the places to put them: three operands.  Given J's two-argument-per-verb
limit, this calls for an adverb.

(x m} y) installs the values (x) into (y) in the places given by (m).

The places to be modified are the ones that would have been selected by
(m { y).  The values (x) are replicated, if necessary, to match the shape
of the selected region, and the result has the shape of (y).

If (x) cannot be replicated an integral number of times to match the
shape of the selected region [strictly, if ($x) is not a suffix of ($m{y)),
an error results.

If (m) is an array, the selected region of (y) is accumulated from the
regions that are selected by the atoms of (m).  These regions should not
overlap and must all have the same shape.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
sel =: < 0 ; 0 2 ; 1 2  NB. Select a subregion
sel { a
(2 2 $'ABCD') sel} a  NB. The modified array
('AB') sel} a  NB. Replication of x
('AB') (< 0 ; 0 2 ; 2 1)} a  NB. Atoms match in order

NB. ============================================================================
Lab Section Modifying an Array: Modification In Place
If (y) is big, (x m} y) can end up copying all of (y) to make a tiny change.

If possible, you should use the form

y =: xexpr mexpr} y

The (y) names must be identical, but (xexpr) and (mexpr) can be expressions.
This will modify (y) without making a new copy.
)
] b =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
b =: ('AB') (< 0 ; 0 2 ; 2 1)} b  NB. Will be performed in place

NB. ============================================================================
Lab Section Modifying an Array: Gerund Form
The form

x v0`v1`v2} y

is equivalent to

(x v0 y) (x v1 y)} (x v2 y)

This is not useful for most work, but in tacit verbs it can come in handy.
It does not allow modification in place.
)
('AB';4 2) (0 {:: [)`(1 {:: [)`]} 'abcdefgh'
'AB' 4 2} 'abcdefgh'  NB. Equivalent form

NB. ============================================================================
Lab Section Selecting From A Structure: Fetch (x {:: y)
(x {:: y) allows you to reach into a structure and pull out an item or
a group of items.

(x) is a list of atoms that will be used successively as the
(x) argument to (x { y).

The first atom x0 is applied, as (x0 { y), giving a result (y1) [see below].
The next atom is applied, as (x1 { y1), giving (y2)  [see below].
The operation continues until (x) is exhausted; the final result is the
last (yn)  [see below].

After each selection, if the result of the selector was an atom, the selected
item is opened, otherwise it is left boxed.

Each selection except possibly the last must select an atom.
)
] b =: (('abc' ; 'ef') ;< ('ghi' ; 'jkl' ; 'mno') ) ; 'pqr'
0 {:: b  NB. Select item 0 and open it
(0;1) {:: b  NB. Select item 1 of the opened item 0
(0;1;2) {:: b  NB. Select item 2 of the opened item 1
(0;1;2;<<2 0) {:: b  NB. Select from the opened character string
(0;1;2;2 0) {:: b  NB. What went wrong?
NB. The last x was <2 0 which selects 2 from axis 0, 0 from axis 1.
NB. But that is invalid for a list.  Another boxing level is needed so the
NB. 2 0 is interpreted as selectors on axis 0

NB. ============================================================================
Lab Section
More examples.
)
] b =: (('abc' ; 'ef') ;< ('ghi' ; 'jkl' ; 'mno') ) ; 'pqr'
(0;1;<<,2) {:: b  NB. Select item 2 of the opened item 1, but a list this time
NB. Note that the result was not opened, because the selector contained a list
(0;1;,2) {:: b  NB. Why does this open the result?
NB. The selector is <,2 .  This is a list of atom selectors, one for
NB. each leading axis.  So while the contents of x is a list ,2 , that is
NB. construed as a list of 1 atom selector; the selector for axis 0 is
NB. the atom 2, so it does not specify a list, and the result is opened.
NB. In <<,2, the selector for axis 0 is ,2 , a list, and the result is opened.

(0;(<<,1);2) {:: b  NB. Error - only the last selection can result in a list
0 {:: b   NB. An atom selector is allowed
1 {:: 'abc'  NB. The y argument does not have to be boxed
0 {:: <5  NB. Fetch from an atom is not allowed (I don't know why)...
0 { <5  NB. ...but selection with { is OK.  Use > x { y if y might be atom

NB. ============================================================================
Lab Chapter Fit Conjunction (!.)
NB. ============================================================================
Lab Section Fit, the All-Purpose Modifier
The fit conjunction (!.) is applied to a verb to create a modified form.
(u!.n), though nominally a modified version of (u), is really a new
primitive whose behavior you cannot guess: you have to learn how
Fit modifies each verb it can be applied to.

Fit can be applied only to primitives.

To ease memorization, the new verb (u!.n) has a function that is
closely related to the function of (u).

The meanings of Fit can be put into several classes which we will
cover one by one.
)

NB. ============================================================================
Lab Section Comparison Tolerance
The most frequent use of Fit is to control the COMPARISON TOLERANCE for
comparison operations.

There is a system variable called the default comparison tolerance [DCT],
which is set to (2^_44) when J starts.  The DCT is used whenever a
comparison is made and is a relative tolerance, meaning that the actual tolerance depends on the numbers being compared.  When you compare (x) and (y), say with (x = y) or (x < y),
an absolute tolerance is calculated which is (DCT * x >.&| y), in other words,
DCT times whichever of (x) or (y) has the larger magnitude.  If the difference
between (x) and (y) is no more than the absolute tolerance, the values are
considered to be equal.

So, 1 = 1.00000000000000000001  is true.  Tolerant comparison means that
you don't have to worry much about floating-point inaccuracies' making
comparisons turn out not-equal when you were expecting equal.

Fit specifies the comparison tolerance for a single comparison, replacing
the DCT in that one verb only, as in (x =!.0 y) which uses a tolerance of 0, i. e.
intolerant comparison.

Fit sets the comparison tolerance for all the dyadic comparison verbs:
  = ~: < > <: >:   and  -: [match]
Fit is meaningless and harmless if characters are compared.  If boxes
are compared, the contents of the boxes are examined, and the comparison
tolerance is used for comparing numeric contents.

The comparison tolerance can be no more than 2^_34 for reason of efficiency
inside the interpreter.  If your comparisons are sloppier than that, write
your own comparison verb.   [(|@:- <!.0 t * >.&:|) is a starting point.]

There is a foreign verb to change the DCT, if you should ever need to do that.
)
1 = 1.0000000000000001  NB. Close enough
1 < 1.0000000000000001  NB. Equal, therefore not less-than
0 = 0.0000000000000001  NB. tolerance is relative.  Against zero, always exact
1000000000000000000001 = 1000000000000000000000  NB. Relative tolerance

NB. Use !.0 for exact comparison:
1 =!.0 (1.0000000000000001)
1 <!.0 (1.0000000000000001)

NB. ============================================================================
Lab Section Implied Comparisons
Comparisons are implied in many verbs besides the basic comparison
verbs.  You can use Fit to set the tolerance for these implied comparisons
also.

The (i.) family of verbs treat one argument as a list and search for
matches within the list.  The verbs in this family are
  (x i. y) (x i: y) (x e. y) (x u/. y) (~. y) (~: y)

Fit can be applied to any of these to set the comparison tolerance.

When Fit is 0, as in (i.!.0), the (i.) family uses a completely different
set of algorithms for comparison.  The (i.!.0) algorithms are usually
faster than the ones used for (i.).

When the argument to be searched is numeric with rank 2 or higher, the (!.0)
form may be much faster.


NOTE that the sort family, (/:), (\:), and (x I. y), always use intolerant comparison.


The Signum verb (* y) also uses the DCT and accepts tolerance specified by
Fit, but for (* y) the DCT is construed as an absolute tolerance rather than a relative
tolerance, because a relative tolerance is ineffective for comparisons against 0.


(x: y), which converts numbers to exact form, finds the simplest
fraction that is tolerantly equal to its argument.  Fit can change
this tolerance.
)
1 2 3 4 5 i. 1.000000000000001  NB. Close enough
1 2 3 4 5 (i.!.0) 1.000000000000001  NB. Not found when exact match required
1 2 1.000000000000001 3 2 </. i. 5  NB. Box matching keys
1 2 1.000000000000001 3 2 </.!.0 i. 5  NB. Require exact matches

0 < 0.000000000000001  NB. Greater than 0 (relative tolerance)
* 0.000000000000001  NB. But signum is 0 (absolute tolerance)

x: 5%3   NB. Convert fraction to exact form
x:!.0 (5%3)  NB.  Intolerant conversion preserves the floating-point noise

NB. ============================================================================
Lab Section Fills: ($!.n) (#!.n) (#^:_1!.n)  ({.!.n) etc.
Verbs that reshape their (y) argument include
(x $ y) (x # y) (x {. y) (x }. y) ({. y) (x {:) (x }.) (x }:)

If the result is bigger than the (y) argument, the verb has to put
something into the added spaces.  (x $ y) repeats its y argument; the
others fill the empty spaces with FILLs which are (0), (' '), or (a:)
depending on the type of the argument.  For dyad (x # y), fills are indicated
by selection counts that have an imaginary component.

For all of these verbs, Fit can be used to specify an atom that will
be put into each extra space.

Note that Fit must specify an atom, NOT an array.

The inverse of (x # y), (x #^:_1 y), expands its (y) argument to match the 1s in its
(x) argument.  Fit can be used to control what goes into the added spaces.
)
3 2 $ 'abc'  NB. Repeat y argument
3 2 $!.'*' 'abc'  NB. Fill with *

1 0 0 1j1 0 2 # 'abcdef'  NB. Fill with spaces
1 0 0 1j1 0 2 #!.'*' 'abcdef'  NB. Fill with *

1 0 0 1 0 1 #^:_1 'adf'  NB. fill with spaces
1 0 0 1 0 1&#^:_1!.'*' 'adf'  NB. fill with *.
1 0 0 1 0 1 #^:_1!.'*' 'adf'  NB. Also works as dyad

5 {. 1 2 3  NB. Overtake, extra spaces are filled with fills (0)
5 {.!.(99) 1 2 3  NB. Fit specifies fill
{.!.99  (0$0)  NB. In the monad, only an empty list can be filled
{.!.'a' (0$0)  NB. Note the type of the empty list can be overridden

NB. ============================================================================
Lab Section Fills In Concatenation Verbs
The verbs that perform concatenation, namely
(x , y) (x ,. y) (x ,: y) (; y)
 have to expand their arguments (or parts of their arguments) to bring them
to a common shape.  During this operation, fills may be added.  The
value to use for the fill can be specified by Fit.

Note that in these verbs, atoms are always expanded by replication,
not by fill, so Fit does not affect them.
)
(i. 2 3) , (,3)  NB. ,3 must be expanded up to a list of shape 3
(i. 2 3) ,!.99 (,3)  NB. The fill can be specified
(i. 2 3) ,!.99 (3)  NB. An atom is always replicated, not filled
(i. 1 2 3) ,!.99 (1 2 3 4)  NB. Both arguments may require fill

(1 2 3) ,: (,5)   NB. Operands must be brought to common shape
(1 2 3) ,:!.99 (,5)  NB. Fill can be specified
(1 2 3) ,:!.99 (5)  NB. atom is replicated, not filled

; (0);(1 2);(i. 1 3)  NB. Items of the highest rank are concatenated
;!.99 (0);(1 2);(i. 1 3)  NB. Fill can be specified, but not for atom

NB. ============================================================================
Lab Section Shift (|.!.n) Including Right Shift 1
(x |. y) is the Rotate Left function, which rotates the items of (y) left
by an amount (x).  Items rotated off one end are rotated back in at the
other end.

When Fit is applied, the items that are rotated off one end are discarded,
and the specified fill atom is used instead to fill the items that are
vacated by the shift.


(|.!.n y) is an example where the Fit conjunction completely
changes the meaning of its verb.  (|. y) is Reverse, which puts the items
of y into reverse order.  (|.!.n y) has nothing to do with Reverse: it
is Shift Right 1, a variant on (x |. y).  (|.!.n y) shifts (y) 1 item
to the right, using (n) as the fill atom for the vacated first position.
It is equivalent to (_1&(|.!.n)).
)
2 |. 'abcdef'  NB. Rotate Left 2
_2 |. 'abcdef'  NB. Rotate Left _2, i. e. Rotate Right
2 |.!.'*' 'abcdef'  NB. Shift, shifting in *
_2 |.!.' ' 'abcdef'  NB. Shift Right, shifting in spaces

|.!.99 (1 2 3 4 5)  NB. Shift Right 1, shifting in 99

NB. ============================================================================
Lab Section Mathematical Frills (x ^!.n y) (x p.!.n y) (C.!.2 y)
Fit is used with the Power verb (x ^ y) to produce a modified power:
x^!.n y   is   */(x + n*i. y)
With (n=0) this is (*/(y $ x)) which is ordinary (x^y).  If you're into Pochhammer symbols you'll love this one.

(x p.!.n y) is the corresponding variant of (p.), in that the atoms of (x)
are coefficients of modified powers of (y).

(C.!.2 y) is not at all like (C. y); instead (C.!.2 y) produces the parity of
the permutation (y): 1 if (y) is derived from the identity permutation by
an even number of pairwise interchanges, _1 if by an odd number,
0 if (y) is not a permutation.
)
5 ^ 3   NB. Normal power
5 * 5 * 5
5 ^!.1 (3)  NB. Modified power
5 * 6 * 7

1 2 1 p. 3  NB. Normal polynomial
+/ 1 2 1 * 3 ^ i.#1 2 1
1 2 1 p.!.1 (3)  NB. Modified polynomial
+/ 1 2 1 * 3 ^!.1 i.#1 2 1

C.!.2 (2 1 0)  NB. 0 1 2->0 2 1->2 0 1->2 1 0, 3 interchanges
C.!.2 (1 2 0)  NB. 0 1 2->1 0 2->1 2 0, 2 interchanges
C.!.2 (0 1 3)  NB. Not a permutation

NB. ============================================================================
Lab Chapter Modular Code and Object-Oriented Programming
NB. ============================================================================
Lab Section Public and Private Names
Named items in J can be PUBLIC or PRIVATE.

Private names are those that are assigned using (=.) [not (=:)] within an explicit
definition.  Such names are visible only within the definition in which
they are assigned.

Public names are those names assigned using (=:), or assigned outside an
explicit definition.  They are visible from anywhere.

In the following, note that pubname was visible inside the explicit definition,
but privname, defined privately, is not visible outside:
)
pubname =: 5
expdef =: verb define
privname =. 5
pubname
)
expdef ''
privname

NB. ============================================================================
Lab Section Locales; Current Locale
Each public entity has a SIMPLE NAME; and also exists in a single LOCALE.

The combination of simple name and locale uniquely identifies the entity.

A locale is a namespace.

The simple name and the locale are orthogonal components of the public
name.  The same simple name can exist in multiple locales, and each
simple-name/locale combination refers to a different entity.

The name of a locale is a character string that is a valid J name with
no underscores, like 'fred'.

The name of a locale may contain all numeric characters, in which case it is a
NUMBERED LOCALE and the leading digit must not be '0'.  Numbered locales are
created by the system to represent objects and you are advised not to use
them for any other purpose.

The interpreter keeps an internal variable, the IMPLIED LOCALE, which is
the locale used in certain default situations.  The initial value of the
implied locale is 'base'; we will learn presently how to change the implied
locale.
)

NB. ============================================================================
Lab Section Locatives
The full name of a public entity, specifying both the simple name and
the locale, is called a LOCATIVE.

Locatives come in two forms, DIRECT:

simplename_localename_

   where the locale name, surrounded by underscores, follows the simple name

and INDIRECT:

simplename__var

   where the locale name, boxed, is contained in the variable (var), which is
separated from the simple name by two underscores.

Normal non-locative name references refer to names in the implied locale.

Any assignment to a locative is public, even if it uses (=.).
)
name =: 5
name
name_base_   NB. name was defined in base locale
name_loc1_ =: 6
name_loc1_
name_base_
name_loc2_ =: +
name_loc2_
name_loc1_ name_loc2_ name

NB. ============================================================================
Lab Section Creating, Deleting, and Listing Locales
To create a locale, simply mention it in a locative.  The locale will be
created.

To delete a locale, use

coerase <'localename'

The locale and all entities in it will be erased.  It is OK to erase a locale
while an entity in it is running; the locale will be erased as soon as no
entity in it is running.

To list the locales in use, use

conl 0 1   NB. 0 for named, 1 for numbered
)
conl 0 1
coerase  NB. coerase is an alias for 18!:55
coerase <'loc1'
conl 0 1

NB. ============================================================================
Lab Section The Search Path
Every locale contains a SEARCH PATH that is used when a name sought in the
locale cannot be found.

The search path is a list of boxed locale names.  When a name sought in
a locale is not found, the interpreter automatically looks for it next in
the first locale in the search path.  If it is not found there, successive
locales from the search path are searched, in order, until the name is found.

You query or set the search path with
   [value to set] copath locale-name
)
name_a_ =: 5
('a';'z') copath <'b'
name_b_  NB. name not found in b, looked up in a
copath <'b'

NB. ============================================================================
Lab Section The z Locale
Every search path should always end with the locale 'z'.

Any entity put into the (z) locale will always be visible from a name search
starting in any locale. [If the same name is defined earlier in the search
path, the earlier entity will be found]
)

NB. ============================================================================
Lab Section Name Lookup in Explicit Definitions
When an explicit definition is running, non-locative name references are first
looked for among the private names of the executing definition.  If the name is
not found there, it is searched for starting in the implied locale.

Locatives in explicit definitions search the specified locale and its search
path, ignoring the private names of the executing definition.
)

NB. ============================================================================
Lab Section Changing the Implied Locale I
You can set the implied locale with

cocurrent locale-name

and query it with

18!:5 ''

You will often find cocurrent at the beginning of a script, to ensure that
all names defined in the file are defined in the given locale.


Whenever a named entity finishes execution, it resets the implied locale to the
value it had on entry to the named entity.
)
name =: 100
name_l2_ =: 'name found in l2'
name
cocurrent <'l2'
name  NB. default lookup now starts in l2
18!:5 ''
cocurrent <'base'
name
18!:5''

NB. ============================================================================
Lab Section Changing the Implied Locale II
Executing an entity named by a locative automatically changes the implied
locale to the locale given in the locative.  The change occurs as the
first action taken by the named entity, meaning that when the entity completes,
it restores the implied locale to whatever it was before the locative was
executed.

The implied locale is always changed to the locale named in the locative, even
if the name was found somewhere else in the search path.

The simplest example of this is the form

name_z_ =: name_xyz_

to define a public entry point.  Then, a sentence like

name 'abc'

executes as follows: 'name' is found in (z) locale; it is executed (in
the implied locale) as name_xyz_; that changes the implied locale to (xyz)
and then executes 'name' in (xyz) locale.

The result is that users just invoke 'name' without having to worry
about what locale it is in, and name runs with access to the variables
in the (xyz) locale.
)
PREPARE
4!:55 <'count'
PREPARE
cocurrent <'xyz'
count =: 0
func =: 3 : 0
count =: >: count
y + count
)
func_z_ =: func_xyz_
cocurrent <'base'
func 0
func 0
func 0
count_xyz_  NB. func ran in xyz; all names defined there
count   NB. not in base

NB. ============================================================================
Lab Section Base Classes
A BASE CLASS is a set of programs with associated private data.  The class
defines methods, which are programs that can access the data.

In J, a base class corresponds to a locale.  There is no way to have truly
private data in a locale, but as long as no program uses locatives to
access the names in the locale, only the base class will touch them.

To define a base class, just put

cocurrent locale-name

at the top of each script file in the class.  All names assigned in the script
will then be defined in the given locale.

The methods can be referred to by locative:

  method-name_locale-name_

or by simple name, if you include the line

  method-name_z_ =: method-name_locale-name_

in the class.  NOTE that adding

  method-name_z_ =: method-name

will not do, because method_name will then be defined as method_name, and
there will be an infinite loop [stack error] when you try to look up the name.
)
cocurrent 'inc'    NB. locale specifier
value =: 0         NB. initialization
add =: 3 : 0       NB. methods
value =: value + y
)
add_z_ =: add_inc_ NB. public interface

cocurrent 'base'
add 3
add 4

NB. ============================================================================
Lab Section Derived Classes
A DERIVED CLASS extends the function of a base class.  It has its own locale,
but also has access to the locale of the base class.

In J, a derived class looks much like a base class.  The extra bit is
that the search path of its base class (i. e. the class the derived class is
extending) is put into the search path of the derived class, so that any
names not found in the derived class will be picked up from the base class.

To insert the base class(es) into the search path of the derived path, include

  coinsert base-class-name(s)

just after setting the locale of the derived class.
)
cocurrent 'inc1'
coinsert 'inc'
add1 =: add @ 1:
add1_z_ =: add1_inc1_

cocurrent 'base'
add1''

NB. ============================================================================
Lab Section Objects in J
An OBJECT is a dynamically created derived class.  The object has its
own individual data-storage area, and shares access to its PARENT CLASS,
which contains programs and any data that is shared by multiple objects.

In J, an object uses two locales: one that is unique to the object, and
one that contains the parent class.  The parent class's locale is put into
the search path of each object derived from the parent.  Methods for the
object are called from the object's locale; the method will be found in the
parent class's locale but will execute in the object's locale.

Entities unique to the object are stored in the object's locale.  Entities,
including code, shared by all objects in the class are stored in the parent
class's locale.

Object locales are created whenever the program wants a new object.  Many
objects sharing the same parent may simultaneously exist.  They are
independent, each isolated in its own locale.  Each has access to
the resources of the parent class.

The parent locale, like the locale for any derived or base class, is created
once, when the script populating the locale is loaded.
)

NB. ============================================================================
Lab Section Each Object Has a Parent Class
The parent class looks like any base or derived class.  In addition it
must define two methods, named (create) and (destroy).

The (create) verb must perform any initialization needed for the object.

The (destroy) verb must release any resources that were acquired by the
object, and then call (codestroy '').
)
NB. Container class.  Numbers can be added and removed.
cocurrent 'container'
create =: verb define
value =: 0$0
)
destroy =: verb define
codestroy''
)

NB. Add number to container, return all values
add =: verb define
value =: value , y
)
NB. Remove number from container, return all values
remove =: verb define
value =: value -. y
)

NB. ============================================================================
Lab Section Creating an Object
With the parent class properly defined, you can create an object whenever
you want one.  There are three steps: [1] create a locale that the object's
entities will be stored in; [2] put the parent class into the path of the
newly-created object locale; [3] call the object's create method to perform
any initialization needed by the object.

The J code to perform these steps is:

objname =: conew unboxed-locale-name-of-base-class
create__objname initialization-parameters

    or the equivalent and preferred shorter form

objname =: initialization-parameters   conew   base-locale-name


The object is a numbered locale, with a system-assigned unique number.
The boxed string containing the locale name is the result of (conew).  You
will assign that result to a name [(objname) above] and then whenever you
want to call a method for the object you will use

  method-name__objname
)
cocurrent 'base'
cont1 =: '' conew 'container'  NB. Needs unused x to be dyad
cont2 =: '' conew 'container'
add__cont1   2 3
remove__cont1 2
add__cont2  i. 4

value__cont2  NB. OK to look at a value directly

NB. ============================================================================
Lab Section Destroying an Object
To destroy an object, call its destroy method.
)
destroy__cont2 ''
value__cont2  NB. The locale no longer exists

NB. ============================================================================
Lab Section Derived Object Classes
An object can be created from a derived class.  As far as accessing methods
goes, this is the same as when any class is derived from another class.  The
difference shows up in the initialization and destruction of the object, at
which times the code for each class in the path must be invoked.

The way to do that is to have each derived class call the create method of
its parent as the first statement in its own create method, and call the
destroy method of its parent as the last statement of its own destroy
method. That way an object will be created from the top of its chain of
class derivation down, and destroyed from the bottom up.

The create method for an object in a class derived from class (xyz) must start
with

create_xyz_ f. y

and the destroy method must end with

destroy_xyz_ f. y


The purpose of the (f.) is to prevent the implied locale from being switched
to (xyz) when the parent's method is called.  All code is run in the locale of
the object.

The (f.) trick is needed only when the parent's method has the same
name [(create)/(destroy)] as the derived class's method, and therefore
has to be called using a locative.  You may call parent
methods that have unique names just by invoking the method as usual,
without the locative.
)

NB. ============================================================================
Lab Chapter Performance
NB. ============================================================================
Lab Section What is J Doing In There?
The sections of this chapter will consider factors that affect the performance
of J programs.  These are:

1.  Interpretive overhead - time spent parsing and executing sentences

2.  Execution overhead - time spent executing verbs

3.  Boxing - how boxing affects storage and execution
)

NB. ============================================================================
Lab Section Interpretive Overhead
J scans each explicit definition, breaking it into words, once when the
entity is defined.

However, J parses each sentence every time it is executed.  It really has no
choice, since the meanings of the names, and even what part of speech they are,
may change from one execution of a sentence to the next.

The parsing is quite fast, and you normally don't have to worry about it.
The one exception is when you have a short verb of low rank that it executed on
a large argument.  Then the repeated parsing may become significant.

The solution is to give your verbs the highest possible rank.

It is usually NOT important to write tacit code to get good performance, unless
you are stuck with a function that has to operate on atoms.
)

NB. ============================================================================
Lab Section Execution Overhead
Every J verb has within it the ability to work on arguments of different
types, and on arrays of any size.  Every verb except the small number of
forms that execute in-place must allocate an output area to hold the result.

When J verbs operate on large arrays, the execution overhead is negligible.
When J verbs operate on atoms, the overhead is a couple of orders of
magnitude larger than the computation time and dominates the overall time.

The way to keep your verbs fast is to ensure that they work on arrays that are
as large as possible.
)

NB. ============================================================================
Lab Section Measuring Performance With (ts)
J gives you a way to see how much time and space your sentences require.
Define

ts =: 6!:2 , 7!:2@]  NB. Return time and space

When you execute a sentence with

ts 'sentence'

the result will be the time it took to run the sentence, and the space used.
For fast sentences, it will be necessary to execute the sentence several times
to get a good average time.  Do that with

repetition-count  ts  'sentence'
)
ts =: 6!:2 , 7!:2@]
a1e6 =: i. 1000000
ts 'a1e6 + a1e6'  NB. Time and space to add 1000000 numbers
ts 'a1e6 +"0 a1e6'  NB. Same with rank 0
plus =: +
ts 'a1e6 plus a1e6'  NB. Same, using a named verb
ts 'a1e6 plus"0 a1e6'  NB. Same, named verb, rank 0

NB. ============================================================================
Lab Section Integrated Rank Support
(x + y), (x +"0 y), and (x plus y) were fast.  (x plus"0 y) was slow.

 1.  If (plus) is defined as (+), why the difference?
 2.  Why was (plus"0) so slow?
 3.  Why wasn't (+"0) also slow?

Verbs are referenced by name.  The value of (plus) is not substituted for it
during parsing; rather, plus starts execution, THEN it is executed according
to its value (+).

This explains why (plus"0) is slow.  The verb that is executed is (plus"0), that
is, an anonymous verb that applies (plus) to each 0-cell.  For each 0-cell,
the name 'plus' is looked up and executed.  That's a million lookups and
verb-starts, which takes a long time.

But then, why isn't (+"0) slow?  And for that matter, why isn't (+) slow, since it
is a rank-0 verb?  The answer is INTEGRATED RANK SUPPORT.  The primitives
have the internal mechanisms to handle arguments of any rank.  And, the
derived verbs created when you assign a rank to a primitive, as with
(+"0), (+"1 2), etc., handle the looping internally with a single verb-start.

Integrated Rank Support means you don't have to worry about the rank of
primitives.  You still have to keep the rank of named verbs as high as
possible.
)

NB. ============================================================================
Lab Section Case Study
Here is a verb to take the geometric mean of the absolute value of its
arguments:

geo =: 4 : '%: (*: x) + (*: y)'
geoabs =: geo&|

What should be done to make this verb faster?
)
geo =: 4 : '%: (*: x) + (*: y)'
geoabs =: geo&|
NB. Create some arguments
xx =: 5 - ? 100000 $ 10
yy =: 5 - ? 100000 $ 10
ts 'xx geoabs yy'
geo1 =: +&.*:   NB. Use dual
geoabs1 =: geo1&|
ts 'xx geoabs1 yy'  NB. Using dual version of geo
geoabs2 =: geo&:|
ts 'xx geoabs2 yy'  NB. Using infinite rank
geoabs3 =: geo1&:|
ts 'xx geoabs3 yy'  NB. Using infinite rank and dual
geo2 =: +&.:*:   NB. Use infinite-rank dual
geoabs4 =: geo2&:|
ts 'xx geoabs4 yy'  NB. Using infinite rank and dual

NB. ============================================================================
Lab Section
After you have tried to understand the results of the different versions of
geoabs, follow the explanation below.
   geo =: 4 : '%: (*: x) + (*: y)'
   geoabs =: geo&|
   ts 'xx geoabs yy'
1.30709 1.05146e6
Because (| y) has rank 0, (x geo&| y) has rank 0 0.  That means that (x geo&| y) is applied to
every pair of atoms.  For each pair, the magnitude verb (| y) is run on each
argument, then the sentence defining (geo) must be parsed, and then it is
executed, with the square verb (*: y) run on each argument, then the (x + y) verb, then
square-root (%: y).

   geo1 =: +&.*:   NB. Use dual
   geoabs1 =: geo1&|
   ts 'xx geoabs1 yy'  NB. Using dual version of geo
0.481445 1.05037e6
By defining (geo) using dual rather than an explicit definition, we avoid having
to parse the sentence for each pair of atoms.  (geo1) is parsed when it is
defined.  But the overall verb still has rank 0, so each operation is executed
on an atom.

   geoabs2 =: geo&:|
   ts 'xx geoabs2 yy'  NB. Using infinite rank
0.00682961 3.67232e6
The big improvement comes by replacing (geo&|) with (geo&:|).  These verbs have
the same function, but (geo&:|) has infinite rank.  Each verb is applied
only once, to the entire argument, and the sentence is parsed only once.

   geoabs3 =: geo1&:|
   ts 'xx geoabs3 yy'  NB. Using infinite rank and dual
0.154895 2.09882e6
When we use (geo1&:|) instead of (geo&:|), performance goes way down.  Why?
Because (geo1), defined as (+&.*:), has the rank of (*: y), namely 0.  So the
(+.), (*:), and (%:) verbs are applied to atoms.  This points up the fact that
using verbs of high rank, not tacit verbs, is what speeds up your programs.
(geo1) is tacit but slow.

   geo2 =: +&.:*:   NB. Use infinite-rank dual
   geoabs4 =: geo2&:|
   ts 'xx geoabs4 yy'  NB. Using infinite rank and dual
0.00642561 2.62272e6
Using (&.:) rather than (&.), we create a version of (geo1) that uses the dual
but has infinite rank.  This is the fastest of all, but not meaningfully faster
than (geoabs2).
)

NB. ============================================================================
Lab Section Boxed Operands
Each noun in J is stored in two parts, HEADER and DATA.  The header contains
the shape and type of the array, and a use count indicating how many references
to the data are active.  The data contains the values in the array, packed
into linear order.

The header and data are stored in different memory allocations.

In a boxed array, the data consists of an array of headers, where each
header points to the data for the contents of the array.  The boxing therefore
corresponds to a level of indirection between the header and the data.

This structure has implications on space and time when you you use boxed arrays:

If the contents of a box are small, the header may add a substantial amount
to the space used by the array;

Executing a verb on the contents of boxes requires opening each box in
turn, which usually requires a verb-start per box.

The upshot is that you should avoid boxed arrays where the contents of the
boxes are small.

You can see how much space a named entity is using by executing

7!:5 <'name'
)
xx =: 5 - ? 100000 $ 10  NB. An array of 100000 floats
7!:5 <'xx'
xxb =: <xx   NB. Boxing the whole array doesn't add much
7!:5 <'xxb'
xxbb =: <"0 xx  NB. But boxing each individual float adds a lot
7!:5 <'xxbb'

NB. ============================================================================
Lab Section Use &.> [aka each] Wherever Possible
The special form (u&.>) applies (u) to the contents of each box of its
arguments, and boxes the result.  It is very fast.

The name (each) is defined as (&.>) by the J startup code.
)
xxbb =: <"0 ] 5 - ? 100000 $ 10  NB. 100000 small boxes
NB. The following two lines have the same function but perform very differently:
20 ts '+:&.> xxbb'
ts '<@+:@> xxbb'
NB. The Conjunction u L:0 applies u at the lowest boxing level and is also fast:
20 ts '+: L:0 xxbb'

NB. &.> is so fast that it even runs faster than @> which doesn't have to
NB. box its result [(&.>) takes more space because its boxed result is much bigger]:
20 ts '+:@> xxbb'

NB. ============================================================================
Lab Section The J Performance Monitor
Thge J Performance Monitor lets you probe your code to see what parts
are taking time.
)
NB. Load the application
load 'plot'
NB. Load the J Performance Monitor
load 'jpm'

NB. Now start timing
start_jpm_ 1e7

NB. Run the application here
plot 0 10;'sin'

NB. Turn off timing and view the result
0 0 85 showtotal_jpm_ ''
NB. Look inside a function
showdetail_jpm_ 'setplotdefaults_jwplot_'

NB. ============================================================================
Lab Chapter Parsing and Execution
NB. ============================================================================
Lab Section The Execution Model
Execution of a J sentence follows these steps:

1.  The sentence is broken into WORDS.  You can use (;: y) to show you what
the words are.

2.  The words are considered as a STACK.  Four 'end-of-line' markers are appended to the words of the sentence, and the stackpointer initially points to the first of these added markers.

3.  The four words starting with the stackpointer are examined to see if
they match an executable pattern.  If they do, 2 or 3 of the words,
depending on the pattern, are the executable FRAGMENT and are EXECUTED and
then replaced by the result of the execution.  If not, the stackpointer
is moved one position to the left.

4.  Step 3 is repeated until the stackpointer moves off the left-hand end of
the sequence of words.

5.  If the stack contains one word, that is the result.  If there is more than
one word, the sentence contains an error.
)

NB. ============================================================================
Lab Section The Parsing Table
The PARSING TABLE that gives the list of allowed executions is shown in
a new window.  Keep it visible for reference.

B stands for beginning-of-line, an extra word that is added at the
beginning of the sentence to act as a stopper, and E stands for the end-of-line markers added at the end.

A stands for Adverb, C for Conjunction, V for Verb, N for Noun.

name stands for any valid target name for an assignment.

The brackets [ ] do not stand for words in the input; they are used
in this version of the table to indicate the fragment that is executed and
replaced by the result of the execution.

The lines are examined in order.  A word matches if its type is one of
those listed for that position in that line.  When the four words at the
stackpointer all match, the line is matched: then the bracketed words are
EXECUTED, which gives a RESULT which is an entity, and that entity
replaces the bracketed words.

Executing a verb always produces a result which is a noun.  Executing a
modifier produces a result which can be any of the four principal parts of
speech.
)
SCRIPT
Word At Stackpointer  Word 1    Word 2    Word 3     Action
B =. =: (             [V        N]        anything   0 Monad
B =. =: ( A V N       V         [V        N]         1 Monad
B =. =: ( A V N       [N        V         N]         2 Dyad
B =. =: ( A V N       [V N      A]        anything   3 Adverb
B =. =: ( A V N       [V N      C         V N]       4 Conj
B =. =: ( A V N       [V N      V         V]         5 Fork
B =. =: (             [C A V N  C A V N]  anything   6 Hook/Adverb
[name N               =. =:     C A V N]  anything   7 Is
[(                    C A V N   )]        anything   8 Paren
SCRIPT
PREPARE
(toHOST SCRIPT_jlab_) 1!:2 <jpath '~temp\parsetable.ijs'
PREPARE
open jpath '~temp\parsetable.ijs'

NB. ============================================================================
Lab Section Name or Value?
When the stackpointer is moved to point to a word, that word
is evaluated if it the name of a noun, an adverb, or a conjunction.
It is not evaluated if it is the name of a verb.

Since verbs and nouns can be passed as arguments to modifiers, this means
that NOUNS are passed BY VALUE, while VERBS are passed BY NAME.

You usually can't tell the difference.
)
NB. Define an adverb that returns the representation of its operand as a noun:
lvalue =: 1 : '5!:5 <''u'' '
'abc' lvalue
+ lvalue
NB. Try it with a named verb operand
voper =: +
voper lvalue
NB. ...and with a noun operand
noper =: 1 2 3
noper lvalue

NB. Note that the noun was replaced by its value, but the verb was not.

NB. ============================================================================
Lab Section Following Execution using the trace facility
To follow parsing and execution, use the trace facility built into J.  Type

   load 'trace'

This defines two verbs: (trace) and (paren).  Each takes a (y) argument which is
a string containing the text of a J sentence.

paren y    returns the fully-parenthesized version of (y)

[x] trace y  gives you a detailed look at parsing and execution of the
           sentence y.  x is the maximum call depth to trace; we will
           be leaving it off, which will show everything.
)
load 'trace'

paren 'i.&1-.3<+/i.5'  NB. A hard-to-read sentence

NB. ============================================================================
Lab Section Examples of Execution 1
We will follow the parsing and execution of a number of sentences of
increasing complexity.

The trace verb does not show the steps of moving the stackpointer, searching
for a match with a line of the parsing table.  It produces a set of output
lines when the stackpointer moves to a position that produces a match.  These
output lines begin with a line that starts with a string of dashes, for example

--------------- 3 Adverb -----

That first line, the one with the dashes, tells you which line of the
parse table was matched.  The bracketed part of that line of the parse table
identifies the fragment, the words that are going to be executed.

The next 3 or 4 lines are the fragment and the result.  The last line is the
result, and the preceding lines are the fragment.  After execution, the
words of the fragment are replaced by the single word of the result.

The first example is very simple: '2 + 3'.   The pattern '2 + 3' matches line
2 of the parsing table, so the verb (+) is executed with left argument 2
and right argument 3.  This has the result 5, which replaces the 3 words
of the fragment on the stack.  There are no more matches, so the result of
the sentence is the value of the one word on the stack, 5.
)
trace '2 + 3'

NB. ============================================================================
Lab Section Examples of Execution 2
The next example is slightly more complex: '(2 + 3)'

The dyad line is the first match, again, with result 5.  Next, the line
for (5) is matched.  Note that 2 + 3 has been replaced, so the three
words (   5   ) are in consecutive stack positions.  The result of the
execution of (5) is 5, which becomes the final result.
)
trace '(2 + 3)'

NB. ============================================================================
Lab Section Examples of Execution 3
+/ 1 2 3

First, note that 1 2 3 is a single word for parsing purposes.

The first match is + /  which is the application of the adverb  /  to the
verb  +  .

The execution of + /  produces a verb which is a single word that replaces
the two words +  and  /  on the stack.

How is this verb indicated?  It has no name; it is an ANONYMOUS VERB.  The
important thing to see is that it is a single verb.  It is represented in the
trace by the string '+/', but that is just a way of telling you its function:
it may not invoke (+) at all during its execution.

An anonymous verb is DISPLAYED using a representation that could be used
to recreate the verb.  It may be EXECUTED any way the interpreter sees fit.
Consider the dyadic verb ((i.&1)@:=).  If you look at the definition of the
components, you will think that each atom of (x) is compared with each atom
of (y) to produce a list of Boolean results, and then that Boolean list is searched to
find the first 1.  But think about it: this is just going to return the index
of the first item of (x) that is equal to the corresponding item of (y).  There's
no need to compare any items after that first match has been found.  And
indeed, the interpreter is clever enough to stop after the first match.  That
is built into the operation of the anonymous verb.  That verb is displayed as
(i.&1@:=), and it is guaranteed to produce the result described by that verb,
but how it does it is not specified.

After + /  is turned into the anonymous verb +/ , that verb is applied to
1 2 3 with the expected result.
)
trace '+/ 1 2 3'

NB. ============================================================================
Lab Section Examples of Execution 4
(3 1 $ 1 2 3) +/ . * (,: 1 2 3)

+/ . * is matrix multiplication, as defined under the (.) conjunction.

The first execution is ',: 1 2 3' to produce an array with shape (1 3),
followed by execution of the surrounding parentheses.

The next executable pattern is   '3 1  $  1 2 3' .  It is a useful exercise
to see why this is the first match (the fundamental reason is, if the
words to the left of +/ produced a conjunction, that conjunction would
have to be executed before any part of +/ . * ; so nothing can be executed
until the parenthesized bit has been executed and it is known what part
of speech it produces).  The result is a 3x1 matrix.

Next the +/ . * is executed, in two parts: + / , which produces an
anonymous verb represented as '+/', and then =/ . * which produces another
anonymous verb represented as '+/ .*' .

Finally, the anonymous verb '+/ .*' is executed as a dyad, to produces the
matrix product.

Note that there is only one verb execution, the final execution of '+/ .*' .
This verb does not invoke the (*) verb, or the code for (+) or (+/).  Matrix
multiplication is an important function, and it is handled with special
code that performs the operation as a unit.  The operation of (+/ . *) is
defined in terms of (*) and (+), but how it is actually executed is the
interpreter's business.
)
trace '(3 1 $ 1 2 3) +/ . * (,: 1 2 3)'

NB. ============================================================================
Lab Section Examples of Execution 5
As a graphic demonstration of the fact that the derived verb is executed
as a verb only once, rather than having its parts executed, we take

5 7 9 11 13 ((+/ % #)@[ - (+/ % #)@]) 1 2 3

This takes the difference between the average value of the left argument
and the right argument.

One point of interest is the parsing of the fork:  +/ % #  is executed
as a fork [the rule is called 'Trident'], which is like the execution of a
conjunction: it produces an anonymous verb that represented the fork.

The result of all the executions of forks, adverbs, and conjunctions
produces a single anonymous verb that performs the entire function.
Then, at the very end, that function is executed.
)
trace '5 7 9 11 13 ((+/ % #)@[ - (+/ % #)@]) 1 2 3'

NB. ============================================================================
Lab Section Final Word
The message to take away from an examination of parsing is that when you
have compounds, the arguments are not substituted into spots in the compounds
according to the definitions of the modifiers.  Rather, the compounds
create anonymous verbs that work on their arguments according to those rules.

In other words,

(+/ % #) y

is not executed as

  (+/ y) % (#y)

but it produces the same result as if it were.
)

NB. ============================================================================
Lab Chapter Plot Package
NB. ============================================================================
Lab Section Overview
The Plot Package lets you do fast 2D and 3D plots.

You give the Plot Package OPTIONS and DATA.  The options control
the display of the data, captioning, etc.

The very fastest plot uses the plot verb.
)
load 'plot'
plot *: i. 20  NB. Just the y values.  X is assumed to be integers.

NB. ============================================================================
Lab Section 2D Line Plots
You can give both x and y values.
)
require 'plot'
require 'trig'
x =: 50 %~ o. i. 100  NB. 100 values of x from 0 to 2p1
plot x ; sin x  NB. abscissas ; ordinates

NB. ============================================================================
Lab Section 2D Point Plots
You can plot points rather than lines.
)
require 'plot'
require 'trig'
x =: 50 %~ o. i. 100  NB. 100 values of x from 0 to 2p1
'point;pensize 3' plot x ; sin x  NB. abscissas ; ordinates

NB. ============================================================================
Lab Section Plots With More Than One Ordinate
You can plot more than one curve on the same plot.
)
require 'plot'
require 'trig'
x =: 50 %~ o. i. 100  NB. 100 values of x from 0 to 2p1
plot x ; (sin ,: cos) x  NB. abscissas ; ordinates

NB. ============================================================================
Lab Section Function Plots
You can plot functions.  Plot will automatically skip over discontinuities.
)
plot _5 5 ; '% y'  NB. domain ; function (reciprocal)

NB. ============================================================================
Lab Section Mixing Plot Types
For more complex plots, you use the pd verb.  pd sends options, data, and
COMMANDS to the Plot Package.  The commands start and display or print the
plot.
)
require 'plot'
require 'trig'
pd 'reset'  NB. Start new plot
pd 'type line; color red'  NB. Start line plot
pd 0 2p1 ; 'sin'  NB. Plot sin function
pd 'type point;pensize 3;color green'  NB. Start dot plot
pd 0 2p1 ; 'cos'  NB. plot cos function as dots
pd 'show'  NB. Show combined plot

NB. ============================================================================
Lab Section Parametric plots
y does not have to be a function of x.
)
require 'plot'
require 'trig'
t =: 50 %~ o. i. 201  NB. 201 values of x from 0 to 4p1
plot (sin t) ; cos 1.5 * t  NB. Parametric function

NB. ============================================================================
Lab Section Surface plots
3D datasets can be plotted either as surfaces or as 3D lines.
)
require 'plot'
require 'trig'
dat=. (];];sin@*/~) i:2j70  NB. x ; y ; sin(x*y) from _2 to 2
pd 'reset'
pd 'type surface'
pd 'edgecolor 64 64 64'
pd 'backcolor lightgray'
pd dat
pd 'show'

NB. ============================================================================
Lab Section Wireframe plots
)
require 'plot'
require 'trig'
dat=. (];];sin@*/~) i:2j70  NB. x ; y ; sin(x*y) from _2 to 2
pd 'reset'
pd 'type wire'
pd 'edgecolor 64 64 64'
pd 'backcolor lightgray'
pd dat
pd 'show'

NB. ============================================================================
Lab Section L'envoi
Plot has a great many other bells and whistles: annotation, other types
of plot, multiple plots arrayed in the same window, and more.
)

NB. ============================================================================
Lab Chapter Writing Modifiers
NB. ============================================================================
Lab Section Two Kinds of Modifiers
You create modifiers with (1 :) [for an adverb] or (2 :) [for a conjunction].

There are two broad classes of modifiers.

PATTERN MODIFIERS are used to express a template for the application
of different verbs.  When such a modifier is given its (u)/(v) operands, it
produces an entity that has the operands inserted into the pattern.
The entity is usually a verb, but it need not be.
This kind of modifier does not refer to (x) or (y) arguments.

LATENT MODIFIERS refer to (x) or (y), and produce only verbs.  Such a
modifier is an ordinary explicit verb that needed another operand or two,
either because two noun arguments were not enough or because some of the
operands are verbs.  When such a modifier is given its (u)/(v) operands,
those operands are saved and made part of a complex that includes the
operands and the definition of the modifier.  This complex is necessarily
a verb, and it is executed when it is given (x)/(y) arguments.  The saved values
of (u)/(v) are only then used by the definition, which is why such modifiers
are called 'latent'.
)

NB. ============================================================================
Lab Section Pattern Modifiers
Pattern modifiers are the way you produce templates of sequences that
occur repeatedly in your code.
)
odisp =: 9!:2''
9!:3 (5)   NB. Set only linear display
NB. Examples of pattern modifiers
NB. Note that when a pattern modifier is given its u/v operands, it
NB. immediately executes its definition and produces a (usually verb)
NB. entity

NB. Conjunction: u unless y is empty; then v
butifnull =: 2 : 'v"_`u@.(*@#@])'
+ butifnull 0

NB. Adverb.  Do u, but skip it if y is null
ifany =: ^: (*@#@])
+ ifany

NB. Adverb.  Apply u and join the results end to end
endtoend =: 1 : ';@:(<@u)'
i."0 endtoend
i."0 endtoend 1 2 3 4

NB. Conjunction for readability.  x u ux_vy v y  is  (u x) v y
ux_vy =: 2 : '(v~ u)~'
+ ux_vy -

NB. m is name of noun; n is default value; result is the value of
NB. the noun if it is defined, otherwise n
butifundef =: 2 : 'if. 0 > 4!:0 <m do. n else. ". m end.'
defname =: 5
'defname' butifundef 0
'undefname' butifundef 0

NB. ============================================================================
Lab Section Latent Modifiers
A latent modifier is just an explicit verb with extra arguments.  When the
modifier is executed, the text of the definition is not examined.  Instead,
a derived verb is produced, comprising the text of the definition and the
(u)/(v) operands.  When this verb is given (x)/(y) arguments, the text of the definition
is executed as a verb.

Like all explicit verbs, a latent modifier may have monadic and dyadic forms,
separated in the definition by a line containing only a (:) character.  Since there is no form for modifiers corresponding to (dyad define) for verbs, the only way to define a dyadic valence for a latent modifier is using the (:) line.
)
9!:3 odisp   NB. restore display
NB. Conjunction.  Apply u at the cell indicated by n
applyintree =: 2 : 0
if. #n do. ((u applyintree (}.n)) L:_1 ({.n){y) ({.n)} y else. u y end.
:
NB. The rank is s,0 where s is the surplus of x-rank over y-rank.  This causes
NB. the cells of y to be matched up with the largest appropriate blocks x  This
NB. is necessary because it is impossible to change the shape of the values being modified
if. #n do. (x u applyintree (}.n) L:_ _1"(0 (,~ >.) x -&(#@$) a) (a =. ({.n){y)) ({.n)} y else. x u y end.
)
>: applyintree (1;2)  NB. This generates a complex, containing the definition
]a =: 1 ; (2 ; 3 ; 4) ;< (5 ; 6)   NB. y argument
>: applyintree (1;2) a   NB. This executes the definition

NB. ============================================================================
Lab Section Prefer Pattern Modifiers Where Possible
If you have a choice between writing a pattern modifier or a latent modifier,
choose the pattern modifier.  It will be interpreted only once, at the
time it is defined.  A latent modifier is interpreted for every cell it
is executed on.
)

